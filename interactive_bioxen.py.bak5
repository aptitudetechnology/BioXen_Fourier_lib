#!/usr/bin/env python3
"""
Interactive BioXen CLI using questionary for user-friendly genome selection and VM management.
Fully integrated with pylua_bioxen_vm_lib v0.1.6 package management system.
"""

import sys
import time
import logging
from pathlib import Path
from typing import List, Dict, Optional, Union

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent / 'src'))

try:
    import questionary
    from questionary import Choice
except ImportError:
    print("âŒ questionary not installed. Install with: pip install questionary")
    sys.exit(1)

# NEW v0.1.6 imports - UPDATED
try:
    from pylua_bioxen_vm_lib import VMManager, InteractiveSession, SessionManager
    from pylua_bioxen_vm_lib.exceptions import (
        InteractiveSessionError, AttachError, DetachError, 
        SessionNotFoundError, SessionAlreadyExistsError, 
        VMManagerError, LuaVMError
    )
    # REQUIRED: Full Package Management System
    from pylua_bioxen_vm_lib.utils.curator import (
        Curator, get_curator, bootstrap_lua_environment, Package,
        PackageRegistry, DependencyResolver, PackageInstaller,
        PackageValidator, get_available_packages, search_packages
    )
    from pylua_bioxen_vm_lib.env import EnvironmentManager, LuaEnvironment
    from pylua_bioxen_vm_lib.package_manager import (
        PackageManager, InstallationManager, RepositoryManager
    )
    MODERN_VM_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  Modern VM library not available: {e}")
    print("ğŸ’¡ Install with: pip install pylua-bioxen-vm-lib")
    MODERN_VM_AVAILABLE = False

try:
    from genome.parser import BioXenRealGenomeIntegrator
    from genome.schema import BioXenGenomeValidator
    from hypervisor.core import BioXenHypervisor, ResourceAllocation, VMState
    from chassis import ChassisType, BaseChassis, EcoliChassis, YeastChassis, OrthogonalChassis
except ImportError as e:
    print(f"âŒ Import error: {e}")
    print("Make sure you're running from the BioXen root directory")
    sys.exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bioxen.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class InteractiveBioXen:
    """Interactive CLI for BioXen hypervisor and package management."""
    def __init__(self):
        """Initialize the interactive BioXen interface with full package management."""
        self.validator = BioXenGenomeValidator()
        self.hypervisor = None
        self.available_genomes = []
        self.chassis_type = ChassisType.ECOLI  # Default chassis
        
        # Terminal visualization support
        self.visualization_monitor = None
        self.visualization_active = False
        
        # REQUIRED: Initialize VM and Package Management
        if MODERN_VM_AVAILABLE:
            self.vm_manager = VMManager()
            
            # Full Package Management System
            self.curator = get_curator()
            self.env_manager = EnvironmentManager()
            self.package_manager = PackageManager()
            self.installation_manager = InstallationManager()
            self.repository_manager = RepositoryManager()
            
            # Initialize package registry
            self.package_registry = PackageRegistry()
            self.dependency_resolver = DependencyResolver()
            self.package_installer = PackageInstaller()
            self.package_validator = PackageValidator()
            
            logger.info("BioXen initialized with full package management system")
        else:
            logger.warning("BioXen initialized without modern VM support")

    def _check_hypervisor(self):
        """Check if the hypervisor is initialized."""
        if self.hypervisor is None:
            print("âŒ Hypervisor not initialized.")
            print("ğŸ’¡ Please select 'Initialize Hypervisor' from the main menu.")
            return False
        return True

    def _suggest_unique_vm_id(self, base_name: str) -> str:
        """Suggest a unique VM ID based on existing VMs."""
        if not self.hypervisor or not self.hypervisor.vms:
            return f"vm_{base_name}"
        
        existing_ids = set(self.hypervisor.vms.keys())
        
        # Try base name first
        candidate = f"vm_{base_name}"
        if candidate not in existing_ids:
            return candidate
        
        # Try with numbers
        for i in range(1, 100):
            candidate = f"vm_{base_name}_{i}"
            if candidate not in existing_ids:
                return candidate
        
        # Fallback with timestamp
        timestamp = int(time.time() % 10000)
        return f"vm_{base_name}_{timestamp}"

    def main_menu(self):
        """Display and handle the main menu with comprehensive package management."""
        while True:
            print("\n" + "="*60)
            print("ğŸ§¬ BioXen Hypervisor - Interactive Genome Management")
            print("="*60)
            
            choices = [
                Choice("ğŸ” Browse Available Genomes", "browse_genomes"),
                Choice("ğŸ§¬ Load Genome for Analysis", "validate"),
                Choice("ğŸ–¥ï¸  Initialize Hypervisor", "init_hypervisor"),
                Choice("ğŸŒ Download New Genomes", "download_new"),
                Choice("âš¡ Create Virtual Machine", "create_vm"),
                Choice("ğŸ“Š Manage Running VMs", "status"),
                Choice("ğŸ“º Terminal DNA Visualization", "terminal_vis"),
                Choice("ğŸ—‘ï¸ Destroy VM", "destroy_vm"),
            ]
            
            # Add Lua VM options if available
            if MODERN_VM_AVAILABLE:
                choices.extend([
                    Choice("ğŸŒ™ Interactive Lua VM (One-shot)", "create_lua_vm"),
                    Choice("ğŸ–¥ï¸  Persistent Lua VM", "create_persistent_vm"),
                    Choice("ğŸ”— Attach to Lua VM", "attach_lua_vm"),
                    Choice("ğŸ“¦ Package Management", "package_management_menu"),
                ])
            
            choices.append(Choice("âŒ Exit", "exit"))
            
            action = questionary.select(
                "What would you like to do?",
                choices=choices,
                use_shortcuts=True
            ).ask()
            
            if action is None or action == "exit":
                print("ğŸ‘‹ Goodbye!")
                break
            
            try:
                if action == "browse_genomes":
                    self.browse_available_genomes()
                elif action == "init_hypervisor":
                    self.initialize_hypervisor()
                elif action == "download_new":
                    self.download_genomes()
                elif action == "validate":
                    self.validate_genomes()
                elif action == "create_vm":
                    self.create_vm()
                elif action == "status":
                    self.show_status()
                elif action == "terminal_vis":
                    self.toggle_terminal_visualization()
                elif action == "destroy_vm":
                    self.destroy_vm()
                elif action == "create_lua_vm" and MODERN_VM_AVAILABLE:
                    self.create_lua_vm()
                elif action == "create_persistent_vm" and MODERN_VM_AVAILABLE:
                    self.create_persistent_vm()
                elif action == "attach_lua_vm" and MODERN_VM_AVAILABLE:
                    self.attach_lua_vm()
                elif action == "package_management_menu" and MODERN_VM_AVAILABLE:
                    self.package_management_menu()
                elif MODERN_VM_AVAILABLE is False:
                    print("âŒ Modern VM features not available. Install pylua-bioxen-vm-lib")
            except KeyboardInterrupt:
                print("\n\nâš ï¸  Operation cancelled by user")
                continue
            except Exception as e:
                logger.error(f"Error in main menu: {e}")
                print(f"\nâŒ Error: {e}")
                questionary.press_any_key_to_continue().ask()

    def package_management_menu(self):
        """Comprehensive package management menu for Lua package operations."""
        while True:
            choices = [
                Choice("ğŸ” Search Packages", "search_lua_packages"),
                Choice("ğŸ“‹ List Installed", "list_installed_packages"),
                Choice("â¬‡ï¸  Install Package", "install_lua_package"),
                Choice("â¬†ï¸  Update Package", "update_lua_package"),
                Choice("ğŸ—‘ï¸  Remove Package", "remove_lua_package"),
                Choice("ğŸ“Š Package Info", "package_info"),
                Choice("ğŸ”„ Update All Packages", "update_all_packages"),
                Choice("ğŸ—ï¸  Bootstrap Environment", "bootstrap_lua_environment"),
                Choice("ğŸ”§ Manage Environments", "manage_lua_environments"),
                Choice("âš™ï¸  Package Settings", "package_settings"),
                Choice("ğŸ”™ Back to Main Menu", "back")
            ]
            
            choice = questionary.select(
                "ğŸ“¦ Package Management",
                choices=choices
            ).ask()
            
            if choice is None or choice == "back":
                break
                
            try:
                if choice == "search_lua_packages":
                    self.search_lua_packages()
                elif choice == "list_installed_packages":
                    self.list_installed_packages()
                elif choice == "install_lua_package":
                    self.install_lua_package()
                elif choice == "update_lua_package":
                    self.update_lua_package()
                elif choice == "remove_lua_package":
                    self.remove_lua_package()
                elif choice == "package_info":
                    self.package_info()
                elif choice == "update_all_packages":
                    self.update_all_packages()
                elif choice == "bootstrap_lua_environment":
                    self.bootstrap_lua_environment()
                elif choice == "manage_lua_environments":
                    self.manage_lua_environments()
                elif choice == "package_settings":
                    self.package_settings()
            except KeyboardInterrupt:
                print("\nâš ï¸ Operation cancelled by user")
                continue
            except Exception as e:
                logger.error(f"Package management error: {e}")
                print(f"âŒ Error: {e}")
                questionary.press_any_key_to_continue().ask()

    def search_lua_packages(self):
        """Search for available Lua packages."""
        query = questionary.text("ğŸ” Enter search query:").ask()
        if not query:
            return
        
        try:
            packages = search_packages(query)
            if packages:
                print(f"\nğŸ“¦ Found {len(packages)} packages:")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("âŒ No packages found")
        except Exception as e:
            logger.error(f"Package search error: {e}")
            print(f"âŒ Search error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def install_lua_package(self):
        """Install a Lua package with dependency resolution."""
        package_name = questionary.text("ğŸ“¦ Package name to install:").ask()
        if not package_name:
            return
        
        version = questionary.text("ğŸ·ï¸  Version (leave empty for latest):").ask()
        
        try:
            print(f"ğŸ”„ Installing package '{package_name}'...")
            if version:
                success = self.package_installer.install_package(package_name, version=version)
            else:
                success = self.package_installer.install_package(package_name)
            
            if success:
                print(f"âœ… Package '{package_name}' installed successfully!")
            else:
                print(f"âŒ Failed to install package '{package_name}'")
        except Exception as e:
            logger.error(f"Package installation error: {e}")
            print(f"âŒ Installation error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def list_installed_packages(self):
        """List all installed Lua packages."""
        try:
            packages = self.package_registry.get_installed_packages()
            if packages:
                print(f"\nğŸ“‹ Installed Packages ({len(packages)}):")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("ğŸ“¦ No packages installed")
        except Exception as e:
            logger.error(f"Error listing packages: {e}")
            print(f"âŒ Error listing packages: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def update_lua_package(self):
        """Update a specific Lua package."""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select(
                "â¬†ï¸  Select package to update:",
                choices=choices
            ).ask()
            
            if package_name:
                print(f"ğŸ”„ Updating package '{package_name}'...")
                success = self.package_installer.update_package(package_name)
                if success:
                    print(f"âœ… Package '{package_name}' updated successfully!")
                else:
                    print(f"âŒ Failed to update package '{package_name}'")
        except Exception as e:
            logger.error(f"Package update error: {e}")
            print(f"âŒ Error updating package: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def remove_lua_package(self):
        """Remove an installed Lua package."""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select(
                "ğŸ—‘ï¸  Select package to remove:",
                choices=choices
            ).ask()
            
            if package_name:
                confirm = questionary.confirm(
                    f"Are you sure you want to remove '{package_name}'?"
                ).ask()
                
                if confirm:
                    success = self.package_installer.remove_package(package_name)
                    if success:
                        print(f"âœ… Package '{package_name}' removed successfully!")
                    else:
                        print(f"âŒ Failed to remove package '{package_name}'")
        except Exception as e:
            logger.error(f"Package removal error: {e}")
            print(f"âŒ Error removing package: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def bootstrap_lua_environment(self):
        """Bootstrap a new Lua environment with essential packages."""
        env_name = questionary.text("ğŸ—ï¸  Environment name:").ask()
        if not env_name:
            return
        
        try:
            print(f"ğŸ”„ Bootstrapping environment '{env_name}'...")
            success = bootstrap_lua_environment(env_name)
            if success:
                print(f"âœ… Lua environment '{env_name}' bootstrapped successfully!")
            else:
                print(f"âŒ Failed to bootstrap environment '{env_name}'")
        except Exception as e:
            logger.error(f"Bootstrap error: {e}")
            print(f"âŒ Bootstrap error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def manage_lua_environments(self):
        """Manage Lua environments."""
        try:
            choices = [
                Choice("ğŸ†• Create New Environment", "create_env"),
                Choice("ğŸ”„ Switch Environment", "switch_env"),
                Choice("ğŸ“‹ List Environments", "list_env"),
                Choice("ğŸ—‘ï¸  Delete Environment", "delete_env"),
                Choice("ğŸ”™ Back", "back")
            ]
            
            action = questionary.select(
                "ğŸ”§ Environment Management:",
                choices=choices
            ).ask()
            
            if action == "create_env":
                env_name = questionary.text("Environment name:").ask()
                if env_name:
                    env = self.env_manager.create_environment(env_name)
                    print(f"âœ… Environment '{env_name}' created!")
            elif action == "switch_env":
                environments = self.env_manager.list_environments()
                if environments:
                    choices = [Choice(env.name, env.name) for env in environments]
                    selected = questionary.select("Select environment:", choices=choices).ask()
                    if selected:
                        self.env_manager.activate_environment(selected)
                        print(f"âœ… Switched to environment '{selected}'")
                else:
                    print("No environments available")
            elif action == "list_env":
                environments = self.env_manager.list_environments()
                if environments:
                    print("\nğŸ“‹ Available Environments:")
                    for env in environments:
                        active = "âœ…" if env.is_active else "  "
                        print(f"  {active} {env.name}")
                else:
                    print("ğŸ“‹ No environments created")
            elif action == "delete_env":
                environments = self.env_manager.list_environments()
                if environments:
                    choices = [Choice(env.name, env.name) for env in environments]
                    selected = questionary.select("Delete environment:", choices=choices).ask()
                    if selected:
                        confirm = questionary.confirm(f"Delete '{selected}'?").ask()
                        if confirm:
                            self.env_manager.delete_environment(selected)
                            print(f"âœ… Environment '{selected}' deleted")
                else:
                    print("No environments to delete")
                    
        except Exception as e:
            logger.error(f"Environment management error: {e}")
            print(f"âŒ Environment management error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def package_info(self):
        """Display detailed package information."""
        package_name = questionary.text("ğŸ“Š Package name for info:").ask()
        if not package_name:
            return
            
        try:
            package_info = self.package_registry.get_package_info(package_name)
            if package_info is None:
                print(f"âŒ Package '{package_name}' not found")
                return
            print(f"\nğŸ“¦ Package Information: {package_name}")
            print(f"   Version: {package_info.version}")
            print(f"   Description: {package_info.description}")
            print(f"   Dependencies: {', '.join(package_info.dependencies) if package_info.dependencies else 'None'}")
            print(f"   Author: {getattr(package_info, 'author', 'Unknown')}")
            print(f"   License: {getattr(package_info, 'license', 'Unknown')}")
        except Exception as e:
            logger.error(f"Error getting package info: {e}")
            print(f"âŒ Error getting package info: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def update_all_packages(self):
        """Update all installed Lua packages."""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
                
            confirm = questionary.confirm(
                f"Update all {len(installed)} installed packages?"
            ).ask()
            
            if not confirm:
                return
                
            print(f"ğŸ”„ Updating {len(installed)} packages...")
            updated_count = 0
            for package in installed:
                try:
                    success = self.package_installer.update_package(package.name)
                    if success:
                        updated_count += 1
                        print(f"  âœ… {package.name} updated")
                    else:
                        print(f"  âš ï¸  {package.name} - no update available")
                except Exception as e:
                    print(f"  âŒ {package.name} - update failed: {e}")
            
            print(f"âœ… Updated {updated_count} out of {len(installed)} packages")
        except Exception as e:
            logger.error(f"Error updating packages: {e}")
            print(f"âŒ Error updating packages: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def package_settings(self):
        """Configure package management settings."""
        try:
            choices = [
                Choice("ğŸ“ View Current Settings", "view_settings"),
                Choice("ğŸ”„ Update Package Repositories", "update_repos"),
                Choice("ğŸ§¹ Clean Package Cache", "clean_cache"),
                Choice("ğŸ”§ Configure Package Manager", "configure"),
                Choice("ğŸ”™ Back", "back")
            ]
            
            action = questionary.select(
                "âš™ï¸  Package Settings:",
                choices=choices
            ).ask()
            
            if action == "view_settings":
                settings = self.package_manager.get_settings()
                print("\nğŸ“ Current Package Settings:")
                for key, value in settings.items():
                    print(f"  {key}: {value}")
            elif action == "update_repos":
                print("ğŸ”„ Updating package repositories...")
                self.repository_manager.update_repositories()
                print("âœ… Repositories updated")
            elif action == "clean_cache":
                print("ğŸ§¹ Cleaning package cache...")
                self.package_manager.clean_cache()
                print("âœ… Cache cleaned")
            elif action == "configure":
                print("ğŸ”§ Package manager configuration")
                print("ğŸ’¡ Configuration options will be added here")
                
        except Exception as e:
            logger.error(f"Settings error: {e}")
            print(f"âŒ Settings error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def create_lua_vm(self):
        """Create a one-shot interactive Lua VM with package management."""
        print("\nğŸŒ™ Interactive Lua VM (One-shot)")
        print("ğŸ’¡ Creates a temporary VM that exits when you're done")
        print("ğŸ’¡ For persistent VMs, use 'Persistent Lua VM' option")
        print("ğŸ“¦ All installed packages are available in this session")
        print("-" * 70)
        
        use_packages = questionary.confirm(
            "ğŸ“¦ Load installed packages in this VM?"
        ).ask()
        
        try:
            with self.vm_manager.create_interactive_session() as session:
                if use_packages:
                    try:
                        installed_packages = self.package_registry.get_installed_packages()
                        for package in installed_packages:
                            session.load_package(package.name)
                        print(f"ğŸ“¦ Loaded {len(installed_packages)} packages")
                    except Exception as e:
                        logger.warning(f"Could not load some packages: {e}")
                        print(f"âš ï¸ Warning: Could not load some packages: {e}")
                
                print("âœ… Lua VM created successfully!")
                print("ğŸ’¡ Type 'exit' or press Ctrl+D to end session")
                print("ğŸ’¡ All standard Lua libraries available")
                if use_packages:
                    print("ğŸ“¦ Installed packages loaded and ready to use")
                print("-" * 50)
                session.interactive_loop()
                print("ğŸ‘‹ Lua session ended")
                
        except KeyboardInterrupt:
            print("\nâš ï¸ Session interrupted by user")
        except (VMManagerError, LuaVMError, InteractiveSessionError) as e:
            logger.error(f"VM Error: {e}")
            print(f"âŒ VM Error: {e}")
        except Exception as e:
            logger.error(f"Unexpected error in Lua session: {e}")
            print(f"âŒ Error in Lua session: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def create_persistent_vm(self):
        """Create a persistent Lua VM that can be attached to later."""
        print("\nğŸ–¥ï¸  Persistent Lua VM")
        print("ğŸ’¡ Creates a persistent VM you can attach to multiple times")
        
        vm_id = questionary.text(
            "Enter VM ID:",
            default=self._suggest_unique_vm_id("persistent_lua"),
            validate=lambda x: x.strip() != "" or "VM ID cannot be empty"
        ).ask()
        
        if not vm_id:
            return
            
        if self.vm_manager.list_sessions() and any(session.vm_id == vm_id for session in self.vm_manager.list_sessions()):
            print(f"âŒ VM ID '{vm_id}' already exists. Please choose a different ID.")
            return
        
        environments = self.env_manager.list_environments()
        env_choices = [Choice("Default Environment", None)]
        env_choices.extend([Choice(env.name, env.name) for env in environments])
        
        selected_env = questionary.select(
            "Select environment:",
            choices=env_choices
        ).ask()
        
        try:
            session = self.vm_manager.create_interactive_vm(vm_id)
            if selected_env:
                session.set_environment(selected_env)
                print(f"ğŸ“¦ Environment '{selected_env}' loaded")
            
            print(f"âœ… Persistent VM '{vm_id}' created successfully!")
            print(f"ğŸ’¡ Use 'Attach to Lua VM' to connect to this VM")
            print(f"ğŸ’¡ VM will persist until manually destroyed")
            
        except (SessionAlreadyExistsError, VMManagerError) as e:
            logger.error(f"VM creation error: {e}")
            print(f"âŒ Failed to create persistent VM: {e}")
        except Exception as e:
            logger.error(f"Unexpected error creating persistent VM: {e}")
            print(f"âŒ Error creating VM: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def attach_lua_vm(self):
        """Attach to an existing persistent Lua VM."""
        print("\nğŸ”— Attach to Lua VM")
        
        try:
            sessions = self.vm_manager.list_sessions()
            if not sessions:
                print("âŒ No persistent VMs available")
                print("ğŸ’¡ Create a persistent VM first")
                return
            
            choices = [Choice(f"ğŸ–¥ï¸  {session.vm_id}", session.vm_id) for session in sessions]
            selected_vm = questionary.select(
                "Select VM to attach to:",
                choices=choices
            ).ask()
            
            if not selected_vm:
                return
                
            print(f"ğŸ”— Attaching to VM '{selected_vm}'...")
            session = self.vm_manager.attach_to_session(selected_vm)
            
            print("âœ… Attached to persistent VM!")
            print("ğŸ’¡ Type 'exit' or press Ctrl+D to detach (VM will remain running)")
            print("-" * 50)
            session.interactive_loop()
            print(f"ğŸ‘‹ Detached from VM '{selected_vm}' (still running)")
            
        except (SessionNotFoundError, AttachError, DetachError) as e:
            logger.error(f"Attach error: {e}")
            print(f"âŒ Failed to attach to VM: {e}")
        except KeyboardInterrupt:
            print("\nâš ï¸ Detached from VM by user")
        except Exception as e:
            logger.error(f"Unexpected error attaching to VM: {e}")
            print(f"âŒ Error attaching to VM: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def select_chassis(self):
        """Let user select biological chassis type."""
        print("\nğŸ§¬ Select Biological Chassis")
        print("Choose the type of cell to use as your virtual machine chassis:")
        
        chassis_choice = questionary.select(
            "Select chassis type:",
            choices=[
                Choice("ğŸ¦  E. coli (Prokaryotic) - Stable, well-tested", ChassisType.ECOLI),
                Choice("ğŸ„ Yeast (Eukaryotic) - PLACEHOLDER - Advanced features", ChassisType.YEAST),
                Choice("ğŸ§© Orthogonal Cell (Synthetic) - Experimental, engineered system", ChassisType.ORTHOGONAL),
            ]
        ).ask()
        
        if chassis_choice is None:
            return None
            
        if chassis_choice in [ChassisType.ECOLI, ChassisType.YEAST, ChassisType.ORTHOGONAL]:
            self.chassis_type = chassis_choice
            if chassis_choice == ChassisType.ECOLI:
                print(f"\nâœ… Selected E. coli chassis")
                print(f"   â€¢ Prokaryotic architecture")
                print(f"   â€¢ 80 ribosomes available")
                print(f"   â€¢ Up to 4 VMs supported")
                print(f"   â€¢ Production-ready implementation")
            elif chassis_choice == ChassisType.YEAST:
                print(f"\nâš ï¸  Selected Yeast chassis (PLACEHOLDER)")
                print(f"   â€¢ Eukaryotic architecture")
                print(f"   â€¢ 200,000 ribosomes available")
                print(f"   â€¢ Organelle support (nucleus, mitochondria, ER)")
                print(f"   â€¢ Up to 2 VMs supported")
                print(f"   â€¢ âš ï¸  PLACEHOLDER - Not fully implemented!")
            elif chassis_choice == ChassisType.ORTHOGONAL:
                print(f"\nâš¡ Selected Orthogonal Cell chassis (EXPERIMENTAL)")
                print(f"   â€¢ Synthetic, engineered cell system")
                print(f"   â€¢ 500 ribosomes available (customizable)")
                print(f"   â€¢ Up to 1 VM supported")
                print(f"   â€¢ âš ï¸  Experimental: For advanced synthetic biology and virtualization")
                print(f"   â€¢ âš ï¸  Hardware requirements may be higher!")
        return chassis_choice

    def initialize_hypervisor(self):
        """Initialize the BioXen hypervisor with chassis selection."""
        if self.hypervisor is not None:
            print("âš ï¸  Hypervisor is already initialized")
            reinit = questionary.confirm("Do you want to reinitialize with a different chassis?").ask()
            if not reinit:
                return
        
        print("\nğŸš€ Initializing BioXen Hypervisor")
        
        selected_chassis = self.select_chassis()
        if selected_chassis is None:
            print("âŒ Chassis selection cancelled")
            return
        
        try:
            print(f"\nğŸ”„ Initializing hypervisor with {self.chassis_type.value} chassis...")
            if self.chassis_type == ChassisType.ECOLI:
                print("   ğŸ¦  Loading E. coli cellular environment...")
                print("   ğŸ§¬ Configuring prokaryotic gene expression...")
                print("   âš™ï¸  Setting up ribosome pools...")
            elif self.chassis_type == ChassisType.YEAST:
                print("   ğŸ„ Loading Saccharomyces cerevisiae environment...")
                print("   ğŸ§¬ Configuring eukaryotic gene expression...")
                print("   ğŸ­ Setting up organelle systems...")
                print("   âš ï¸  Note: Using PLACEHOLDER implementation")
            elif self.chassis_type == ChassisType.ORTHOGONAL:
                print("   ğŸ§© Loading Orthogonal Cell synthetic environment...")
                print("   ğŸ§¬ Configuring engineered gene expression...")
                print("   âš¡ Setting up custom ribosome pools...")
                print("   âš ï¸  Note: Experimental synthetic cell chassis")
            
            self.hypervisor = BioXenHypervisor(chassis_type=self.chassis_type)
            
            if self.chassis_type == ChassisType.YEAST:
                print(f"\nâš ï¸  WARNING: Yeast chassis is currently a PLACEHOLDER implementation")
                print(f"   This chassis provides basic functionality for testing but")
                print(f"   does not include full eukaryotic cellular mechanisms.")
            elif self.chassis_type == ChassisType.ORTHOGONAL:
                print(f"\nâš¡ WARNING: Orthogonal Cell chassis is EXPERIMENTAL")
                print(f"   This chassis is designed for advanced synthetic biology and virtualization.")
                print(f"   Hardware requirements may be higher. Use with caution!")
            
            print(f"\nâœ… BioXen Hypervisor initialized successfully!")
            print(f"   Chassis: {self.chassis_type.value}")
            print(f"   Status: Ready for genome virtualization")
            
        except Exception as e:
            logger.error(f"Hypervisor initialization failed: {e}")
            print(f"âŒ Failed to initialize hypervisor: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def browse_available_genomes(self):
        """Browse and display available genomes with detailed information."""
        print("\nğŸ” Browse Available Genomes")
        print("ğŸ“‹ Scanning local genome collection...")
        
        genome_dir = Path("genomes")
        if not genome_dir.exists():
            print("âŒ No genomes directory found.")
            print("ğŸ’¡ Use 'Download genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        genome_files = list(genome_dir.glob("*.genome"))
        
        if not genome_files:
            print("âŒ No genome files found in genomes/ directory.")
            print("ğŸ’¡ Use 'Download genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        print(f"âœ… Found {len(genome_files)} real bacterial genomes")
        print("="*60)
        
        for i, genome_file in enumerate(genome_files, 1):
            try:
                name = genome_file.stem
                size_kb = genome_file.stat().st_size / 1024
                
                print(f"\n{i}. ğŸ§¬ {name}")
                print(f"   ğŸ“ File: {genome_file.name}")
                print(f"   ğŸ’¾ Size: {size_kb:.1f} KB")
                
                try:
                    integrator = BioXenRealGenomeIntegrator(genome_file)
                    stats = integrator.get_genome_stats()
                    if stats:
                        print(f"   ğŸ”¬ Genes: {stats.get('total_genes', 'Unknown')}")
                        if 'essential_genes' in stats:
                            essential_pct = stats.get('essential_percentage', 0)
                            print(f"   âš¡ Essential: {stats['essential_genes']} ({essential_pct:.1f}%)")
                        print(f"   ğŸ¦  Organism: {stats.get('organism', 'Unknown')}")
                        
                        template = integrator.create_vm_template()
                        if template:
                            print(f"   ğŸ–¥ï¸  VM Memory: {template.get('min_memory_kb', 'Unknown')} KB")
                            print(f"   â±ï¸  Boot Time: {template.get('boot_time_ms', 'Unknown')} ms")
                except Exception as e:
                    logger.warning(f"Error reading genome details for {genome_file}: {e}")
                    print(f"   ğŸ“Š Status: File available (details pending validation)")
                    
            except Exception as e:
                logger.error(f"Error processing genome {genome_file}: {e}")
                print(f"   âŒ Error reading genome: {e}")
                
        print("\n" + "="*60)
        print(f"ğŸ“‹ Total: {len(genome_files)} real bacterial genomes available")
        print("ğŸ’¡ Use 'Load Genome for Analysis' to work with a specific genome")
        print("ğŸ§¬ Use 'Create Virtual Machine' to virtualize these genomes")
        
        questionary.press_any_key_to_continue().ask()

    def download_genomes(self):
        """Download genomes from NCBI with interactive selection."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ“¥ Download Genomes from NCBI")
        print("âœ… BioXen supports real bacterial genome downloads and management")
        print("ğŸ“‹ Current collection: 5 real minimal bacterial genomes available")
        print("ğŸ”„ Options: Download all real genomes, individual genomes, or create simulated data for testing.")
        
        genome_options = [
            {
                "display": "ğŸŒ Download All Real Bacterial Genomes - Complete minimal genome collection",
                "accession": "download_all_real",
                "name": "all_real_genomes", 
                "size": 0
            },
            {
                "display": "ğŸ¦  E. coli K-12 MG1655 - Classic lab strain",
                "accession": "NC_000913.3",
                "name": "E_coli_K12_MG1655",
                "size": 4641652
            },
            {
                "display": "ğŸ„ S. cerevisiae S288C - Baker's yeast reference",
                "accession": "NC_001133.9", 
                "name": "S_cerevisiae_S288C",
                "size": 230218
            },
            {
                "display": "ğŸ”¬ Mycoplasma genitalium - Minimal genome",
                "accession": "NC_000908.2",
                "name": "M_genitalium",
                "size": 580076
            },
            {
                "display": "ğŸŒŠ Prochlorococcus marinus - Tiny ocean bacteria",
                "accession": "NC_009840.1",
                "name": "P_marinus",
                "size": 1751080
            },
            {
                "display": "ğŸ’€ Clostridium botulinum - Botox producer",
                "accession": "NC_009495.1", 
                "name": "C_botulinum",
                "size": 3886916
            },
            {
                "display": "ğŸ§ª Custom genome - Enter your own accession",
                "accession": "custom",
                "name": "custom",
                "size": 1000000
            }
        ]
        
        choice = questionary.select(
            "Select a genome to download:",
            choices=[Choice(opt["display"], opt) for opt in genome_options]
        ).ask()
        
        if choice is None:
            return
            
        if choice["accession"] == "download_all_real":
            self._download_all_real_genomes()
        elif choice["accession"] == "custom":
            self._download_custom_genome()
        else:
            self._download_individual_genome(choice)
        
        questionary.press_any_key_to_continue().ask()

    def _download_all_real_genomes(self):
        """Download all real bacterial genomes."""
        print("\nğŸŒ Downloading All Real Bacterial Genomes")
        print("ğŸ”„ Launching genome downloader for complete minimal genome collection...")
        print("ğŸ“‹ This will download: JCVI-Syn3A, M. genitalium, M. pneumoniae, C. ruddii, B. aphidicola")
        
        confirm = questionary.confirm(
            "Download all 5 real bacterial genomes? This may take several minutes."
        ).ask()
        
        if not confirm:
            return
            
        try:
            import subprocess
            result = subprocess.run([
                sys.executable, 'download_genomes.py', 'all'
            ], capture_output=True, text=True, cwd=Path(__file__).parent)
            
            if result.returncode == 0:
                print("âœ… Successfully downloaded all real bacterial genomes!")
                print("ğŸ“‹ Available genomes:")
                print("   â€¢ JCVI-Syn3A (538 KB, 187 genes)")
                print("   â€¢ Mycoplasma genitalium (580 KB, 1,108 genes)")
                print("   â€¢ Mycoplasma pneumoniae (823 KB, 1,503 genes)")
                print("   â€¢ Carsonella ruddii (174 KB, 473 genes)")
                print("   â€¢ Buchnera aphidicola (640 KB, 583 genes)")
                print("\nğŸ§¬ You can now use 'Browse Available Genomes' to work with these real genomes!")
            else:
                print(f"âŒ Download failed: {result.stderr}")
                print("ğŸ’¡ Try running 'python3 download_genomes.py' separately for more details")
                
        except Exception as e:
            logger.error(f"Genome download error: {e}")
            print(f"âŒ Error launching genome downloader: {e}")
            print("ğŸ’¡ Try running 'python3 download_genomes.py all' manually")

    def _download_individual_genome(self, genome_choice):
        """Download an individual genome."""
        accession = genome_choice["accession"]
        name = genome_choice["name"]
        size = genome_choice["size"]
        
        print(f"\nğŸŒ Downloading Real Genome: {name}")
        print(f"   Accession: {accession}")
        print(f"   Expected size: {size:,} base pairs")
        print(f"ğŸ’¡ Using NCBI download tools for authentic genome data")
        
        confirm = questionary.confirm(
            f"Download {name} from NCBI? This may take a few minutes."
        ).ask()
        
        if not confirm:
            return
        
        try:
            from genome_download_helper import GenomeDownloadHelper
            
            download_helper = GenomeDownloadHelper("genomes")
            success, message = download_helper.download_genome(accession, name)
            
            genome_file = Path("genomes") / f"{name}.genome"
            file_actually_downloaded = genome_file.exists() and genome_file.stat().st_size > 1000
            
            if file_actually_downloaded:
                file_size_mb = genome_file.stat().st_size / (1024 * 1024)
                print(f"âœ… Successfully downloaded {name}!")
                print(f"   ğŸ“Š Authentic NCBI data ({file_size_mb:.1f} MB)")
                print(f"   ğŸ§¬ Ready for biological virtualization")
                print(f"   ğŸ“ File: {genome_file}")
            elif success:
                print(f"âœ… Download helper reported success: {message}")
                print(f"   ğŸ“Š Authentic NCBI data for {name}")
                print(f"   ğŸ§¬ Ready for biological virtualization")
            else:
                print(f"âš ï¸  Download helper returned: {message}")
                print("ğŸ”„ Creating simulated genome for testing...")
                self._create_simulated_genome(accession, name, size)
                
        except ImportError:
            print("âš ï¸  Advanced download helper not available")
            print("ğŸ”„ Creating simulated genome for testing...")
            self._create_simulated_genome(accession, name, size)
                
        except Exception as e:
            logger.error(f"Individual genome download error: {e}")
            print(f"âŒ Error downloading genome: {e}")
            print("ğŸ”„ Creating simulated genome for testing...")
            self._create_simulated_genome(accession, name, size)

    def _download_custom_genome(self):
        """Download a custom genome by accession."""
        accession = questionary.text("Enter NCBI accession number (e.g., NC_000913.3):").ask()
        if not accession:
            return
        name = questionary.text("Enter a name for this genome:").ask()
        if not name:
            name = accession.replace(".", "_")
        size = 1000000
        
        genome_choice = {"accession": accession, "name": name, "size": size}
        self._download_individual_genome(genome_choice)

    def _create_simulated_genome(self, accession: str, name: str, size: int):
        """Create simulated genome data for testing purposes."""
        print(f"\nğŸ”„ Generating simulated genome data for {accession}...")
        print(f"ğŸ’¡ Creating simulated genome data for testing and development")
        
        try:
            import random
            bases = ['A', 'T', 'G', 'C']
            genome_data = ''.join(random.choice(bases) for _ in range(size))
            
            if genome_data:
                self.available_genomes.append({
                    "accession": accession,
                    "name": name,
                    "data": genome_data
                })
                print(f"âœ… Successfully created simulated {name}")
                print(f"   Accession: {accession}")
                print(f"   Size: {len(genome_data):,} base pairs")
                print(f"   âš ï¸  Note: This is simulated data for testing purposes")
            else:
                print(f"âŒ Failed to create genome data for {accession}")
        except Exception as e:
            logger.error(f"Simulated genome creation error: {e}")
            print(f"âŒ Error creating genome data: {e}")

    def validate_genomes(self):
        """Validate downloaded genomes."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ§¬ Load Genome for Analysis")
        print("ğŸ“‹ Scanning for available genomes...")
        
        genome_dir = Path("genomes")
        if not genome_dir.exists():
            print("âŒ No genomes directory found.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        genome_files = list(genome_dir.glob("*.genome"))
        
        if not genome_files:
            print("âŒ No genome files found in genomes/ directory.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        print(f"âœ… Found {len(genome_files)} genome files")
        
        genome_choices = []
        valid_genomes = []
        
        for genome_file in genome_files:
            try:
                name = genome_file.stem
                size_kb = genome_file.stat().st_size / 1024
                
                integrator = BioXenRealGenomeIntegrator(genome_file)
                try:
                    stats = integrator.get_genome_stats()
                    organism = stats.get('organism', name)
                    gene_count = stats.get('total_genes', 'Unknown')
                    display_name = f"ğŸ§¬ {organism} ({gene_count} genes, {size_kb:.1f} KB)"
                except Exception:
                    display_name = f"ğŸ§¬ {name} ({size_kb:.1f} KB)"
                
                genome_info = {
                    'name': name,
                    'file_path': genome_file,
                    'display_name': display_name
                }
                
                genome_choices.append(Choice(display_name, genome_info))
                valid_genomes.append(genome_info)
                
            except Exception as e:
                logger.warning(f"Could not read {genome_file.name}: {e}")
                print(f"âš ï¸  Warning: Could not read {genome_file.name}: {e}")
        
        if not valid_genomes:
            print("âŒ No valid genomes found.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        genome_choices.append(Choice("ğŸ” Validate all genomes", "all"))
        
        choice = questionary.select(
            "Select a genome to validate:",
            choices=genome_choices
        ).ask()
        
        if choice is None:
            return
            
        if choice == "all":
            self._validate_all_genomes(valid_genomes)
        else:
            self._validate_single_genome(choice)
        
        questionary.press_any_key_to_continue().ask()

    def _validate_all_genomes(self, valid_genomes):
        """Validate all available genomes."""
        print("\nğŸ”„ Validating all available genomes...")
        all_valid = True
        for genome_info in valid_genomes:
            print(f"\nğŸ”¬ Validating {genome_info['name']}...")
            try:
                is_valid, messages = self.validator.validate_genome(genome_info['file_path'])
                if is_valid:
                    print(f"âœ… {genome_info['name']} is a valid BioXen genome.")
                else:
                    print(f"âŒ {genome_info['name']} is NOT a valid BioXen genome:")
                    for msg in messages:
                        print(f"   - {msg}")
                    all_valid = False
            except Exception as e:
                logger.error(f"Error validating {genome_info['name']}: {e}")
                print(f"âŒ Error validating {genome_info['name']}: {e}")
                all_valid = False
        
        if all_valid:
            print("\nâœ… All available genomes validated successfully!")
        else:
            print("\nâš ï¸  Some genomes failed validation. Check the logs above.")

    def _validate_single_genome(self, genome_choice):
        """Validate a single genome."""
        print(f"\nğŸ”¬ Validating {genome_choice['name']}...")
        try:
            is_valid, messages = self.validator.validate_genome(genome_choice['file_path'])
            if is_valid:
                print(f"âœ… {genome_choice['name']} is a valid BioXen genome.")
                self.available_genomes.append({
                    "name": genome_choice['name'],
                    "file_path": genome_choice['file_path'],
                    "data": None
                })
                print(f"ğŸ’¡ {genome_choice['name']} is now available for VM creation.")
            else:
                print(f"âŒ {genome_choice['name']} is NOT a valid BioXen genome:")
                for msg in messages:
                    print(f"   - {msg}")
        except Exception as e:
            logger.error(f"Error validating {genome_choice['name']}: {e}")
            print(f"âŒ Error validating {genome_choice['name']}: {e}")

    def create_vm(self):
        """Create a new virtual machine."""
        if not self._check_hypervisor():
            return

        print("\nâš¡ Create Virtual Machine")
        print("ğŸ“‹ Scanning for available genomes to virtualize...")

        genome_dir = Path("genomes")
        if not genome_dir.exists() or not list(genome_dir.glob("*.genome")):
            print("âŒ No genome files found. Please download or validate genomes first.")
            print("ğŸ’¡ Use 'Download New Genomes' or 'Load Genome for Analysis' options.")
            questionary.press_any_key_to_continue().ask()
            return

        genome_choices = []
        for genome_file in genome_dir.glob("*.genome"):
            try:
                integrator = BioXenRealGenomeIntegrator(genome_file)
                stats = integrator.get_genome_stats()
                organism_name = stats.get('organism', genome_file.stem)
                genome_choices.append(Choice(f"ğŸ§¬ {organism_name} ({genome_file.stem})", genome_file))
            except Exception:
                genome_choices.append(Choice(f"ğŸ§¬ {genome_file.stem} (Error reading details)", genome_file))

        if not genome_choices:
            print("âŒ No valid genomes found to create a VM from.")
            questionary.press_any_key_to_continue().ask()
            return

        selected_genome_path = questionary.select(
            "Select a genome to virtualize:",
            choices=genome_choices
        ).ask()

        if selected_genome_path is None:
            print("âŒ VM creation cancelled.")
            return

        genome_name = selected_genome_path.stem
        vm_id = self._suggest_unique_vm_id(genome_name)

        print(f"\nâš™ï¸  Configuring VM for {genome_name}")

        min_memory_kb = 1024
        boot_time_ms = 100
        try:
            integrator = BioXenRealGenomeIntegrator(selected_genome_path)
            template = integrator.create_vm_template()
            if template:
                min_memory_kb = template.get('min_memory_kb', min_memory_kb)
                boot_time_ms = template.get('boot_time_ms', boot_time_ms)
        except Exception as e:
            logger.warning(f"Could not load VM template from genome: {e}")
            print(f"âš ï¸  Could not load VM template from genome: {e}. Using default resources.")

        print(f"   Suggested Minimum Memory: {min_memory_kb} KB")
        print(f"   Suggested Boot Time: {boot_time_ms} ms")

        mem_input = questionary.text(
            f"Enter memory allocation in KB (default: {min_memory_kb}):",
            default=str(min_memory_kb),
            validate=lambda x: x.isdigit() and int(x) > 0 or "Must be a positive number"
        ).ask()
        memory_kb = int(mem_input) if mem_input else min_memory_kb

        boot_input = questionary.text(
            f"Enter simulated boot time in ms (default: {boot_time_ms}):",
            default=str(boot_time_ms),
            validate=lambda x: x.isdigit() and int(x) > 0 or "Must be a positive number"
        ).ask()
        boot_time = int(boot_input) if boot_input else boot_time_ms

        resource_allocation = ResourceAllocation(memory_kb=memory_kb, boot_time_ms=boot_time)

        try:
            print(f"\nğŸ”„ Creating VM '{vm_id}' for {genome_name}...")
            self.hypervisor.create_vm(vm_id, selected_genome_path, resource_allocation)
            print(f"âœ… VM '{vm_id}' created successfully!")
            print(f"   Genome: {genome_name}")
            print(f"   Memory: {memory_kb} KB")
            print(f"   Boot Time: {boot_time} ms")
            print(f"   State: {self.hypervisor.get_vm_state(vm_id).value}")
        except Exception as e:
            logger.error(f"VM creation failed: {e}")
            print(f"âŒ Failed to create VM: {e}")

        questionary.press_any_key_to_continue().ask()

    def show_status(self):
        """Display the status of the hypervisor and running VMs."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ“Š BioXen Hypervisor Status")
        print("="*60)
        print(f"Chassis Type: {self.hypervisor.chassis_type.value}")
        print(f"Total Ribosomes: {self.hypervisor.chassis.total_ribosomes}")
        print(f"Available Ribosomes: {self.hypervisor.chassis.available_ribosomes}")
        print(f"Max VMs Supported: {self.hypervisor.chassis.max_vms}")
        print(f"Current Active VMs: {len(self.hypervisor.vms)}")
        print("="*60)
        
        if not self.hypervisor.vms:
            print("No virtual machines are currently running.")
            print("ğŸ’¡ Use 'Create Virtual Machine' to get started.")
        else:
            print("\nğŸ–¥ï¸  Virtual Machine States:")
            for vm_id, vm_instance in self.hypervisor.vms.items():
                state = self.hypervisor.get_vm_state(vm_id)
                print(f"   â€¢ VM ID: {vm_id}")
                print(f"     Status: {state.value}")
                print(f"     Genome: {vm_instance.genome_name}")
                print(f"     Memory: {vm_instance.resources.memory_kb} KB")
                print(f"     Boot Time: {vm_instance.resources.boot_time_ms} ms")
                
                if state == VMState.RUNNING:
                    vm_actions = questionary.select(
                        f"Actions for VM '{vm_id}':",
                        choices=[
                            Choice("â¹ï¸ Stop VM", "stop"),
                            Choice("ğŸ”„ Restart VM", "restart"),
                            Choice("ğŸ—‘ï¸ Destroy VM", "destroy"),
                            Choice("â†©ï¸ Back", "back")
                        ]
                    ).ask()
                    
                    if vm_actions == "stop":
                        self.hypervisor.stop_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' stopped.")
                    elif vm_actions == "restart":
                        self.hypervisor.restart_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' restarted.")
                    elif vm_actions == "destroy":
                        self.hypervisor.destroy_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' destroyed.")
                    elif vm_actions == "back":
                        pass
        
        questionary.press_any_key_to_continue().ask()

    def destroy_vm(self):
        """Destroy a selected virtual machine."""
        if not self._check_hypervisor():
            return
        
        if not self.hypervisor.vms:
            print("âŒ No virtual machines to destroy.")
            questionary.press_any_key_to_continue().ask()
            return
            
        vm_choices = [Choice(f"{vm_id} ({self.hypervisor.get_vm_state(vm_id).value})", vm_id)
                      for vm_id in self.hypervisor.vms.keys()]
                      
        vm_to_destroy = questionary.select(
            "Select VM to destroy:",
            choices=vm_choices
        ).ask()
        
        if vm_to_destroy is None:
            print("âŒ VM destruction cancelled.")
            return
            
        confirm = questionary.confirm(f"Are you sure you want to destroy VM '{vm_to_destroy}'? This action is irreversible.").ask()
        
        if confirm:
            try:
                self.hypervisor.destroy_vm(vm_to_destroy)
                p#!/usr/bin/env python3
"""
Interactive BioXen CLI using questionary for user-friendly genome selection and VM management.
Fully integrated with pylua_bioxen_vm_lib v0.1.6 package management system.
"""

import sys
import time
import shutil
import subprocess
import logging
from datetime import datetime
from contextlib import contextmanager

from pathlib import Path
from typing import List, Dict, Optional, Union

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent / 'src'))

try:
    import questionary
    from questionary import Choice
except ImportError:
    print("âŒ questionary not installed. Install with: pip install questionary")
    sys.exit(1)

# NEW v0.1.6 imports - UPDATED
try:
    from pylua_bioxen_vm_lib import VMManager, InteractiveSession, SessionManager
    from pylua_bioxen_vm_lib.vm_manager import VMCluster
    from pylua_bioxen_vm_lib.networking import NetworkedLuaVM, validate_host, validate_port
    from pylua_bioxen_vm_lib.lua_process import LuaProcess
    from pylua_bioxen_vm_lib.exceptions import (
        InteractiveSessionError, AttachError, DetachError, 
        SessionNotFoundError, SessionAlreadyExistsError, 
        VMManagerError, ProcessRegistryError, LuaProcessError,
        NetworkingError, LuaVMError
    )

    # REQUIRED: Full Package Management System
    from pylua_bioxen_vm_lib.utils.curator import (
        Curator, get_curator, bootstrap_lua_environment, Package,
        PackageRegistry, DependencyResolver, PackageInstaller,
        PackageValidator, get_available_packages, search_packages
    )
    from pylua_bioxen_vm_lib.env import EnvironmentManager, LuaEnvironment
    from pylua_bioxen_vm_lib.package_manager import (
        PackageManager, InstallationManager, RepositoryManager
    )
    MODERN_VM_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸  Modern VM library not available: {e}")
    print("ğŸ’¡ Install with: pip install pylua-bioxen-vm-lib")
    MODERN_VM_AVAILABLE = False

try:
    from genome.parser import BioXenRealGenomeIntegrator
    from genome.schema import BioXenGenomeValidator
    from hypervisor.core import BioXenHypervisor, ResourceAllocation, VMState
    from chassis import ChassisType, BaseChassis, EcoliChassis, YeastChassis, OrthogonalChassis
except ImportError as e:
    print(f"âŒ Import error: {e}")
    print("Make sure you're running from the BioXen root directory")
    sys.exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bioxen.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class InteractiveBioXen:
    def package_management_menu(self):
        """Comprehensive package management menu"""
        choices = [
            Choice("ğŸ” Search Packages", "search_lua_packages"),
            Choice("ğŸ“‹ List Installed", "list_installed_packages"),
            Choice("â¬‡ï¸  Install Package", "install_lua_package"),
            Choice("â¬†ï¸  Update Package", "update_lua_package"),
            Choice("ğŸ—‘ï¸  Remove Package", "remove_lua_package"),
            Choice("ğŸ“Š Package Info", "package_info"),
            Choice("ğŸ”„ Update All Packages", "update_all_packages"),
            Choice("ğŸ—ï¸  Bootstrap Environment", "bootstrap_lua_environment"),
            Choice("ğŸ”§ Manage Environments", "manage_lua_environments"),
            Choice("âš™ï¸  Package Settings", "package_settings"),
            Choice("ğŸ”™ Back to Main Menu", "main_menu")
        ]
        choice = questionary.select("ğŸ“¦ Package Management", choices=choices).ask()
        if choice and choice != "main_menu":
            getattr(self, choice)()

    def search_lua_packages(self):
        """Search for available Lua packages"""
        query = questionary.text("ğŸ” Enter search query:").ask()
        if not query:
            return
        try:
            packages = search_packages(query)
            if packages:
                print(f"\nğŸ“¦ Found {len(packages)} packages:")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("âŒ No packages found")
        except Exception as e:
            print(f"âŒ Search error: {e}")

    def install_lua_package(self):
        """Install a Lua package with dependency resolution"""
        package_name = questionary.text("ğŸ“¦ Package name to install:").ask()
        if not package_name:
            return
        version = questionary.text("ğŸ·ï¸  Version (leave empty for latest):").ask()
        try:
            if version:
                success = self.package_installer.install_package(package_name, version=version)
            else:
                success = self.package_installer.install_package(package_name)
            if success:
                print(f"âœ… Package '{package_name}' installed successfully!")
            else:
                print(f"âŒ Failed to install package '{package_name}'")
        except Exception as e:
            print(f"âŒ Installation error: {e}")

    def list_installed_packages(self):
        """List all installed packages"""
        try:
            packages = self.package_registry.get_installed_packages()
            if packages:
                print(f"\nğŸ“‹ Installed Packages ({len(packages)}):")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("ğŸ“¦ No packages installed")
        except Exception as e:
            print(f"âŒ Error listing packages: {e}")

    def update_lua_package(self):
        """Update a specific Lua package"""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select("â¬†ï¸  Select package to update:", choices=choices).ask()
            if not package_name:
                return
            try:
                success = self.package_installer.update_package(package_name)
                if success:
                    print(f"âœ… Package '{package_name}' updated successfully!")
                else:
                    print(f"âŒ Failed to update package '{package_name}'")
            except Exception as e:
                print(f"âŒ Update error: {e}")
        except Exception as e:
            print(f"âŒ Error updating package: {e}")

    def remove_lua_package(self):
        """Remove an installed Lua package"""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select("ğŸ—‘ï¸  Select package to remove:", choices=choices).ask()
            if package_name:
                success = self.package_installer.remove_package(package_name)
                if success:
                    print(f"âœ… Package '{package_name}' removed successfully!")
                else:
                    print(f"âŒ Failed to remove package '{package_name}'")
        except Exception as e:
            print(f"âŒ Error removing package: {e}")

    def bootstrap_lua_environment(self):
        """Bootstrap a new Lua environment with essential packages"""
        env_name = questionary.text("ğŸ—ï¸  Environment name:").ask()
        if not env_name:
            return
        try:
            success = bootstrap_lua_environment(env_name)
            if success:
                print(f"âœ… Lua environment '{env_name}' bootstrapped successfully!")
            else:
                print(f"âŒ Failed to bootstrap environment '{env_name}'")
        except Exception as e:
            print(f"âŒ Bootstrap error: {e}")

    def manage_lua_environments(self):
        """Manage Lua environments"""
        try:
            environments = self.env_manager.list_environments()
            choices = [
                Choice("ğŸ†• Create New Environment", "create_env"),
                Choice("ğŸ”„ Switch Environment", "switch_env"),
                Choice("ğŸ“‹ List Environments", "list_env"),
                Choice("ğŸ—‘ï¸  Delete Environment", "delete_env"),
                Choice("ğŸ”™ Back", "back")
            ]
            action = questionary.select("ğŸ”§ Environment Management:", choices=choices).ask()
            # Implement environment management actions (create, switch, list, delete)
        except Exception as e:
            print(f"âŒ Environment management error: {e}")
    def __init__(self):
        """Initialize the interactive BioXen interface with full package management."""
        self.validator = BioXenGenomeValidator()
        self.hypervisor = None
        self.available_genomes = []
        self.chassis_type = ChassisType.ECOLI  # Default chassis
        
        # Terminal visualization support
        self.visualization_monitor = None
        self.visualization_active = False
        
        # REQUIRED: Initialize VM and Package Management
        if MODERN_VM_AVAILABLE:
            self.vm_manager = VMManager()
            
            # Full Package Management System
            self.curator = get_curator()
            self.env_manager = EnvironmentManager()
            self.package_manager = PackageManager()
            self.installation_manager = InstallationManager()
            self.repository_manager = RepositoryManager()
            
            # Initialize package registry
            self.package_registry = PackageRegistry()
            self.dependency_resolver = DependencyResolver()
            self.package_installer = PackageInstaller()
            self.package_validator = PackageValidator()
            
            logger.info("BioXen initialized with full package management system")
        else:
            logger.warning("BioXen initialized without modern VM support")

    def _suggest_unique_vm_id(self, base_name: str) -> str:
        """Suggest a unique VM ID based on existing VMs."""
        if not self.hypervisor or not self.hypervisor.vms:
            return f"vm_{base_name}"
        
        existing_ids = set(self.hypervisor.vms.keys())
        
        # Try base name first
        candidate = f"vm_{base_name}"
        if candidate not in existing_ids:
            return candidate
        
        # Try with numbers
        for i in range(1, 100):
            candidate = f"vm_{base_name}_{i}"
            if candidate not in existing_ids:
                return candidate
        
        # Fallback with timestamp
        import time
        timestamp = int(time.time() % 10000)
        return f"vm_{base_name}_{timestamp}"

    def main_menu(self):
        """Display and handle the main menu with comprehensive package management."""
        while True:
            print("\n" + "="*60)
            print("ğŸ§¬ BioXen Hypervisor - Interactive Genome Management")
            print("="*60)
            
            choices = [
                Choice("ğŸ” Browse Available Genomes", "browse_genomes"),
                Choice("ğŸ§¬ Load Genome for Analysis", "validate"),
                Choice("ğŸ–¥ï¸  Initialize Hypervisor", "init_hypervisor"),
                Choice("ğŸ“¥ Download genomes", "download"),
                Choice("âš¡ Create Virtual Machine", "create_vm"),
                Choice("ğŸ“Š Manage Running VMs", "status"),
                Choice("ğŸ“º Terminal DNA Visualization", "terminal_vis"),
                Choice("ğŸ“ˆ View System Status", "view_status"),
                Choice("ğŸŒ Download New Genomes", "download_new"),
            ]
            
            # Add Lua VM options if available
            if MODERN_VM_AVAILABLE:
                choices.extend([
                    Choice("ğŸŒ™ Interactive Lua VM (One-shot)", "create_lua_vm"),
                    Choice("ğŸ–¥ï¸  Persistent Lua VM", "create_persistent_vm"),
                    Choice("ğŸ”— Attach to Lua VM", "attach_lua_vm"),
                    Choice("ğŸ“¦ Package Management", "package_management_menu"),
                    Choice("ğŸ” Search Lua Packages", "search_lua_packages"),
                    Choice("ğŸ“‹ List Installed Packages", "list_installed_packages"),
                    Choice("â¬‡ï¸  Install Lua Package", "install_lua_package"),
                    Choice("â¬†ï¸  Update Lua Package", "update_lua_package"),
                    Choice("ğŸ—‘ï¸  Remove Lua Package", "remove_lua_package"),
                    Choice("ğŸ”§ Manage Lua Environments", "manage_lua_environments"),
                    Choice("ğŸ—ï¸  Bootstrap Lua Environment", "bootstrap_lua_environment"),
                ])
            
            choices.append(Choice("âŒ Exit", "exit"))
            
            action = questionary.select(
                "What would you like to do?",
                choices=choices,
                use_shortcuts=True
            ).ask()
            
            if action is None or action == "exit":
                print("ğŸ‘‹ Goodbye!")
                break
            
            try:
                if action == "browse_genomes":
                    self.browse_available_genomes()
                elif action == "init_hypervisor":
                    self.initialize_hypervisor()
                elif action == "download":
                    self.download_genomes()
                elif action == "download_new":
                    self.download_genomes()  # Same as download for now
                elif action == "validate":
                    self.validate_genomes()
                elif action == "create_vm":
                    self.create_vm()
                elif action == "status":
                    self.show_status()
                elif action == "view_status":
                    self.show_status()  # Same as status for now
                elif action == "terminal_vis":
                    self.toggle_terminal_visualization()
                elif action == "destroy_vm":
                    self.destroy_vm()
                # NEW: Modern Lua VM and Package Management
                elif action == "create_lua_vm" and MODERN_VM_AVAILABLE:
                    self.create_lua_vm()
                elif action == "create_persistent_vm" and MODERN_VM_AVAILABLE:
                    self.create_persistent_vm()
                elif action == "attach_lua_vm" and MODERN_VM_AVAILABLE:
                    self.attach_lua_vm()
                elif action == "package_management_menu" and MODERN_VM_AVAILABLE:
                    self.package_management_menu()
                elif action == "search_lua_packages" and MODERN_VM_AVAILABLE:
                    self.search_lua_packages()
                elif action == "list_installed_packages" and MODERN_VM_AVAILABLE:
                    self.list_installed_packages()
                elif action == "install_lua_package" and MODERN_VM_AVAILABLE:
                    self.install_lua_package()
                elif action == "update_lua_package" and MODERN_VM_AVAILABLE:
                    self.update_lua_package()
                elif action == "remove_lua_package" and MODERN_VM_AVAILABLE:
                    self.remove_lua_package()
                elif action == "manage_lua_environments" and MODERN_VM_AVAILABLE:
                    self.manage_lua_environments()
                elif action == "bootstrap_lua_environment" and MODERN_VM_AVAILABLE:
                    self.bootstrap_lua_environment()
                elif MODERN_VM_AVAILABLE is False:
                    print("âŒ Modern VM features not available. Install pylua-bioxen-vm-lib")
            except KeyboardInterrupt:
                print("\n\nâš ï¸  Operation cancelled by user")
                continue
            except Exception as e:
                logger.error(f"Error in main menu: {e}")
                print(f"\nâŒ Error: {e}")
                questionary.press_any_key_to_continue().ask()

    # REQUIRED: Comprehensive Package Management Methods
    def package_management_menu(self):
        """Comprehensive package management menu"""
        while True:
            choices = [
                Choice("ğŸ” Search Packages", "search_lua_packages"),
                Choice("ğŸ“‹ List Installed", "list_installed_packages"),
                Choice("â¬‡ï¸  Install Package", "install_lua_package"),
                Choice("â¬†ï¸  Update Package", "update_lua_package"),
                Choice("ğŸ—‘ï¸  Remove Package", "remove_lua_package"),
                Choice("ğŸ“Š Package Info", "package_info"),
                Choice("ğŸ”„ Update All Packages", "update_all_packages"),
                Choice("ğŸ—ï¸  Bootstrap Environment", "bootstrap_lua_environment"),
                Choice("ğŸ”§ Manage Environments", "manage_lua_environments"),
                Choice("âš™ï¸  Package Settings", "package_settings"),
                Choice("ğŸ”™ Back to Main Menu", "back")
            ]
            
            choice = questionary.select(
                "ğŸ“¦ Package Management",
                choices=choices
            ).ask()
            
            if choice is None or choice == "back":
                break
                
            try:
                if choice == "search_lua_packages":
                    self.search_lua_packages()
                elif choice == "list_installed_packages":
                    self.list_installed_packages()
                elif choice == "install_lua_package":
                    self.install_lua_package()
                elif choice == "update_lua_package":
                    self.update_lua_package()
                elif choice == "remove_lua_package":
                    self.remove_lua_package()
                elif choice == "package_info":
                    self.package_info()
                elif choice == "update_all_packages":
                    self.update_all_packages()
                elif choice == "bootstrap_lua_environment":
                    self.bootstrap_lua_environment()
                elif choice == "manage_lua_environments":
                    self.manage_lua_environments()
                elif choice == "package_settings":
                    self.package_settings()
            except Exception as e:
                logger.error(f"Package management error: {e}")
                print(f"âŒ Error: {e}")
                questionary.press_any_key_to_continue().ask()

    def search_lua_packages(self):
        """Search for available Lua packages"""
        query = questionary.text("ğŸ” Enter search query:").ask()
        if not query:
            return
        
        try:
            packages = search_packages(query)
            if packages:
                print(f"\nğŸ“¦ Found {len(packages)} packages:")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("âŒ No packages found")
        except Exception as e:
            logger.error(f"Package search error: {e}")
            print(f"âŒ Search error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def install_lua_package(self):
        """Install a Lua package with dependency resolution"""
        package_name = questionary.text("ğŸ“¦ Package name to install:").ask()
        if not package_name:
            return
        
        # Optional version specification
        version = questionary.text("ğŸ·ï¸  Version (leave empty for latest):").ask()
        
        try:
            print(f"ğŸ”„ Installing package '{package_name}'...")
            # Use the full package installation system
            if version:
                success = self.package_installer.install_package(package_name, version=version)
            else:
                success = self.package_installer.install_package(package_name)
            
            if success:
                print(f"âœ… Package '{package_name}' installed successfully!")
            else:
                print(f"âŒ Failed to install package '{package_name}'")
        except Exception as e:
            logger.error(f"Package installation error: {e}")
            print(f"âŒ Installation error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def list_installed_packages(self):
        """List all installed packages"""
        try:
            packages = self.package_registry.get_installed_packages()
            if packages:
                print(f"\nğŸ“‹ Installed Packages ({len(packages)}):")
                for pkg in packages:
                    print(f"  â€¢ {pkg.name} ({pkg.version}) - {pkg.description}")
            else:
                print("ğŸ“¦ No packages installed")
        except Exception as e:
            logger.error(f"Error listing packages: {e}")
            print(f"âŒ Error listing packages: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def update_lua_package(self):
        """Update a specific Lua package"""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select(
                "â¬†ï¸  Select package to update:",
                choices=choices
            ).ask()
            
            if package_name:
                print(f"ğŸ”„ Updating package '{package_name}'...")
                success = self.package_installer.update_package(package_name)
                if success:
                    print(f"âœ… Package '{package_name}' updated successfully!")
                else:
                    print(f"âŒ Failed to update package '{package_name}'")
        except Exception as e:
            logger.error(f"Package update error: {e}")
            print(f"âŒ Error updating package: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def remove_lua_package(self):
        """Remove an installed Lua package"""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
            
            choices = [Choice(f"{pkg.name} ({pkg.version})", pkg.name) for pkg in installed]
            package_name = questionary.select(
                "ğŸ—‘ï¸  Select package to remove:",
                choices=choices
            ).ask()
            
            if package_name:
                confirm = questionary.confirm(
                    f"Are you sure you want to remove '{package_name}'?"
                ).ask()
                
                if confirm:
                    success = self.package_installer.remove_package(package_name)
                    if success:
                        print(f"âœ… Package '{package_name}' removed successfully!")
                    else:
                        print(f"âŒ Failed to remove package '{package_name}'")
        except Exception as e:
            logger.error(f"Package removal error: {e}")
            print(f"âŒ Error removing package: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def bootstrap_lua_environment(self):
        """Bootstrap a new Lua environment with essential packages"""
        env_name = questionary.text("ğŸ—ï¸  Environment name:").ask()
        if not env_name:
            return
        
        try:
            print(f"ğŸ”„ Bootstrapping environment '{env_name}'...")
            # Use the curator system to bootstrap
            success = bootstrap_lua_environment(env_name)
            if success:
                print(f"âœ… Lua environment '{env_name}' bootstrapped successfully!")
            else:
                print(f"âŒ Failed to bootstrap environment '{env_name}'")
        except Exception as e:
            logger.error(f"Bootstrap error: {e}")
            print(f"âŒ Bootstrap error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def manage_lua_environments(self):
        """Manage Lua environments"""
        try:
            choices = [
                Choice("ğŸ†• Create New Environment", "create_env"),
                Choice("ğŸ”„ Switch Environment", "switch_env"),
                Choice("ğŸ“‹ List Environments", "list_env"),
                Choice("ğŸ—‘ï¸  Delete Environment", "delete_env"),
                Choice("ğŸ”™ Back", "back")
            ]
            
            action = questionary.select(
                "ğŸ”§ Environment Management:",
                choices=choices
            ).ask()
            
            if action == "create_env":
                env_name = questionary.text("Environment name:").ask()
                if env_name:
                    env = self.env_manager.create_environment(env_name)
                    print(f"âœ… Environment '{env_name}' created!")
            elif action == "switch_env":
                environments = self.env_manager.list_environments()
                if environments:
                    choices = [Choice(env.name, env.name) for env in environments]
                    selected = questionary.select("Select environment:", choices=choices).ask()
                    if selected:
                        self.env_manager.activate_environment(selected)
                        print(f"âœ… Switched to environment '{selected}'")
                else:
                    print("No environments available")
            elif action == "list_env":
                environments = self.env_manager.list_environments()
                if environments:
                    print("\nğŸ“‹ Available Environments:")
                    for env in environments:
                        active = "âœ…" if env.is_active else "  "
                        print(f"  {active} {env.name}")
                else:
                    print("ğŸ“‹ No environments created")
            elif action == "delete_env":
                environments = self.env_manager.list_environments()
                if environments:
                    choices = [Choice(env.name, env.name) for env in environments]
                    selected = questionary.select("Delete environment:", choices=choices).ask()
                    if selected:
                        confirm = questionary.confirm(f"Delete '{selected}'?").ask()
                        if confirm:
                            self.env_manager.delete_environment(selected)
                            print(f"âœ… Environment '{selected}' deleted")
                else:
                    print("No environments to delete")
                    
        except Exception as e:
            logger.error(f"Environment management error: {e}")
            print(f"âŒ Environment management error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def package_info(self):
        """Display detailed package information"""
        package_name = questionary.text("ğŸ“Š Package name for info:").ask()
        if not package_name:
            return
            
        try:
            # Try to get package info from registry
            package_info = self.package_registry.get_package_info(package_name)
            if package_info:
                print(f"\nğŸ“¦ Package Information: {package_name}")
                print(f"   Version: {package_info.version}")
                print(f"   Description: {package_info.description}")
                print(f"   Dependencies: {', '.join(package_info.dependencies) if package_info.dependencies else 'None'}")
                print(f"   Author: {getattr(package_info, 'author', 'Unknown')}")
                print(f"   License: {getattr(package_info, 'license', 'Unknown')}")
            else:
                print(f"âŒ Package '{package_name}' not found")
        except Exception as e:
            print(f"âŒ Error getting package info: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def update_all_packages(self):
        """Update all installed packages"""
        try:
            installed = self.package_registry.get_installed_packages()
            if not installed:
                print("ğŸ“¦ No packages installed")
                return
                
            confirm = questionary.confirm(
                f"Update all {len(installed)} installed packages?"
            ).ask()
            
            if not confirm:
                return
                
            print(f"ğŸ”„ Updating {len(installed)} packages...")
            updated_count = 0
            for package in installed:
                try:
                    success = self.package_installer.update_package(package.name)
                    if success:
                        updated_count += 1
                        print(f"  âœ… {package.name} updated")
                    else:
                        print(f"  âš ï¸  {package.name} - no update available")
                except Exception as e:
                    print(f"  âŒ {package.name} - update failed: {e}")
            
            print(f"âœ… Updated {updated_count} out of {len(installed)} packages")
        except Exception as e:
            print(f"âŒ Error updating packages: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def package_settings(self):
        """Configure package management settings"""
        try:
            choices = [
                Choice("ğŸ“ View Current Settings", "view_settings"),
                Choice("ğŸ”„ Update Package Repositories", "update_repos"),
                Choice("ğŸ§¹ Clean Package Cache", "clean_cache"),
                Choice("ğŸ”§ Configure Package Manager", "configure"),
                Choice("ğŸ”™ Back", "back")
            ]
            
            action = questionary.select(
                "âš™ï¸  Package Settings:",
                choices=choices
            ).ask()
            
            if action == "view_settings":
                settings = self.package_manager.get_settings()
                print("\nğŸ“ Current Package Settings:")
                for key, value in settings.items():
                    print(f"  {key}: {value}")
            elif action == "update_repos":
                print("ğŸ”„ Updating package repositories...")
                self.repository_manager.update_repositories()
                print("âœ… Repositories updated")
            elif action == "clean_cache":
                print("ğŸ§¹ Cleaning package cache...")
                self.package_manager.clean_cache()
                print("âœ… Cache cleaned")
            elif action == "configure":
                print("ğŸ”§ Package manager configuration")
                # Add configuration options as needed
                print("ğŸ’¡ Configuration options will be added here")
                
        except Exception as e:
            print(f"âŒ Settings error: {e}")
        
        questionary.press_any_key_to_continue().ask()

    # MODERNIZED: Lua VM Methods with Package Management
    def create_lua_vm(self):
        """Create a one-shot interactive Lua VM with package management (modernized for v0.1.6)"""
        print("\nğŸŒ™ Interactive Lua VM (One-shot)")
        print("ğŸ’¡ Creates a temporary VM that exits when you're done")
        print("ğŸ’¡ For persistent VMs, use 'Persistent Lua VM' option")
        print("ğŸ“¦ All installed packages are available in this session")
        print("-" * 70)
        
        # REQUIRED: Ask about package environment
        use_packages = questionary.confirm(
            "ğŸ“¦ Load installed packages in this VM?"
        ).ask()
        
        try:
            with self.vm_manager.create_interactive_session() as session:
                # REQUIRED: Initialize package environment if requested
                if use_packages:
                    try:
                        # Load all installed packages into the VM
                        installed_packages = self.package_registry.get_installed_packages()
                        for package in installed_packages:
                            session.load_package(package.name)
                        print(f"ğŸ“¦ Loaded {len(installed_packages)} packages")
                    except Exception as e:
                        logger.warning(f"Could not load some packages: {e}")
                        print(f"âš ï¸ Warning: Could not load some packages: {e}")
                
                print("âœ… Lua VM created successfully!")
                print("ğŸ’¡ Type 'exit' or press Ctrl+D to end session")
                print("ğŸ’¡ All standard Lua libraries available")
                if use_packages:
                    print("ğŸ“¦ Installed packages loaded and ready to use")
                print("-" * 50)
                session.interactive_loop()
                print("ğŸ‘‹ Lua session ended")
                
        except KeyboardInterrupt:
            print("\nâš ï¸ Session interrupted by user")
        except (VMManagerError, LuaVMError, InteractiveSessionError) as e:
            logger.error(f"VM Error: {e}")
            print(f"âŒ VM Error: {e}")
        except Exception as e:
            logger.error(f"Unexpected error in Lua session: {e}")
            print(f"âŒ Error in Lua session: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def create_persistent_vm(self):
        """Create a persistent Lua VM that can be attached to later"""
        print("\nğŸ–¥ï¸  Persistent Lua VM")
        print("ğŸ’¡ Creates a persistent VM you can attach to multiple times")
        
        vm_id = questionary.text(
            "Enter VM ID:",
            default=self._suggest_unique_vm_id("persistent_lua")
        ).ask()
        
        if not vm_id:
            return
            
        # Ask about environment
        environments = self.env_manager.list_environments()
        env_choices = [Choice("Default Environment", None)]
        env_choices.extend([Choice(env.name, env.name) for env in environments])
        
        selected_env = questionary.select(
            "Select environment:",
            choices=env_choices
        ).ask()
        
        try:
            session = self.vm_manager.create_interactive_vm(vm_id)
            if selected_env:
                session.set_environment(selected_env)
                print(f"ğŸ“¦ Environment '{selected_env}' loaded")
            
            print(f"âœ… Persistent VM '{vm_id}' created successfully!")
            print(f"ğŸ’¡ Use 'Attach to Lua VM' to connect to this VM")
            print(f"ğŸ’¡ VM will persist until manually destroyed")
            
        except (SessionAlreadyExistsError, VMManagerError) as e:
            logger.error(f"VM creation error: {e}")
            print(f"âŒ Failed to create persistent VM: {e}")
        except Exception as e:
            logger.error(f"Unexpected error creating persistent VM: {e}")
            print(f"âŒ Error creating VM: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def attach_lua_vm(self):
        """Attach to an existing persistent Lua VM"""
        print("\nğŸ”— Attach to Lua VM")
        
        try:
            # Get list of available VMs
            sessions = self.vm_manager.list_sessions()
            if not sessions:
                print("âŒ No persistent VMs available")
                print("ğŸ’¡ Create a persistent VM first")
                return
            
            choices = [Choice(f"ğŸ–¥ï¸  {session.vm_id}", session.vm_id) for session in sessions]
            selected_vm = questionary.select(
                "Select VM to attach to:",
                choices=choices
            ).ask()
            
            if not selected_vm:
                return
                
            print(f"ğŸ”— Attaching to VM '{selected_vm}'...")
            session = self.vm_manager.attach_to_session(selected_vm)
            
            print("âœ… Attached to persistent VM!")
            print("ğŸ’¡ Type 'exit' or press Ctrl+D to detach (VM will remain running)")
            print("-" * 50)
            session.interactive_loop()
            print(f"ğŸ‘‹ Detached from VM '{selected_vm}' (still running)")
            
        except (SessionNotFoundError, AttachError, DetachError) as e:
            logger.error(f"Attach error: {e}")
            print(f"âŒ Failed to attach to VM: {e}")
        except KeyboardInterrupt:
            print("\nâš ï¸ Detached from VM by user")
        except Exception as e:
            logger.error(f"Unexpected error attaching to VM: {e}")
            print(f"âŒ Error attaching to VM: {e}")
        
        questionary.press_any_key_to_continue().ask()

    # Existing BioXen methods remain unchanged
    def select_chassis(self):
        """Let user select biological chassis type."""
        print("\nğŸ§¬ Select Biological Chassis")
        print("Choose the type of cell to use as your virtual machine chassis:")
        
        chassis_choice = questionary.select(
            "Select chassis type:",
            choices=[
                Choice("ğŸ¦  E. coli (Prokaryotic) - Stable, well-tested", ChassisType.ECOLI),
                Choice("ğŸ„ Yeast (Eukaryotic) - PLACEHOLDER - Advanced features", ChassisType.YEAST),
                Choice("ğŸ§© Orthogonal Cell (Synthetic) - Experimental, engineered system", ChassisType.ORTHOGONAL),
            ]
        ).ask()
        
        if chassis_choice is None:
            return None
            
        if chassis_choice in [ChassisType.ECOLI, ChassisType.YEAST, ChassisType.ORTHOGONAL]:
            self.chassis_type = chassis_choice
            if chassis_choice == ChassisType.ECOLI:
                print(f"\nâœ… Selected E. coli chassis")
                print(f"   â€¢ Prokaryotic architecture")
                print(f"   â€¢ 80 ribosomes available")
                print(f"   â€¢ Up to 4 VMs supported")
                print(f"   â€¢ Production-ready implementation")
            elif chassis_choice == ChassisType.YEAST:
                print(f"\nâš ï¸  Selected Yeast chassis (PLACEHOLDER)")
                print(f"   â€¢ Eukaryotic architecture")
                print(f"   â€¢ 200,000 ribosomes available")
                print(f"   â€¢ Organelle support (nucleus, mitochondria, ER)")
                print(f"   â€¢ Up to 2 VMs supported")
                print(f"   â€¢ âš ï¸  PLACEHOLDER - Not fully implemented!")
            elif chassis_choice == ChassisType.ORTHOGONAL:
                print(f"\nâš¡ Selected Orthogonal Cell chassis (EXPERIMENTAL)")
                print(f"   â€¢ Synthetic, engineered cell system")
                print(f"   â€¢ 500 ribosomes available (customizable)")
                print(f"   â€¢ Up to 1 VM supported")
                print(f"   â€¢ âš ï¸  Experimental: For advanced synthetic biology and virtualization")
                print(f"   â€¢ âš ï¸  Hardware requirements may be higher!")
        return chassis_choice

    def initialize_hypervisor(self):
        """Initialize the BioXen hypervisor with chassis selection."""
        if self.hypervisor is not None:
            print("âš ï¸  Hypervisor is already initialized")
            reinit = questionary.confirm("Do you want to reinitialize with a different chassis?").ask()
            if not reinit:
                return
        
        print("\nğŸš€ Initializing BioXen Hypervisor")
        
        # Let user select chassis
        selected_chassis = self.select_chassis()
        if selected_chassis is None:
            print("âŒ Chassis selection cancelled")
            return
        
        try:
            print(f"\nğŸ”„ Initializing hypervisor with {self.chassis_type.value} chassis...")
            if self.chassis_type == ChassisType.ECOLI:
                print("   ğŸ¦  Loading E. coli cellular environment...")
                print("   ğŸ§¬ Configuring prokaryotic gene expression...")
                print("   âš™ï¸  Setting up ribosome pools...")
            elif self.chassis_type == ChassisType.YEAST:
                print("   ğŸ„ Loading Saccharomyces cerevisiae environment...")
                print("   ğŸ§¬ Configuring eukaryotic gene expression...")
                print("   ğŸ­ Setting up organelle systems...")
                print("   âš ï¸  Note: Using PLACEHOLDER implementation")
            elif self.chassis_type == ChassisType.ORTHOGONAL:
                print("   ğŸ§© Loading Orthogonal Cell synthetic environment...")
                print("   ğŸ§¬ Configuring engineered gene expression...")
                print("   âš¡ Setting up custom ribosome pools...")
                print("   âš ï¸  Note: Experimental synthetic cell chassis")
            
            self.hypervisor = BioXenHypervisor(chassis_type=self.chassis_type)
            
            # Show warning for placeholder/experimental implementations
            if self.chassis_type == ChassisType.YEAST:
                print(f"\nâš ï¸  WARNING: Yeast chassis is currently a PLACEHOLDER implementation")
                print(f"   This chassis provides basic functionality for testing but")
                print(f"   does not include full eukaryotic cellular mechanisms.")
            elif self.chassis_type == ChassisType.ORTHOGONAL:
                print(f"\nâš¡ WARNING: Orthogonal Cell chassis is EXPERIMENTAL")
                print(f"   This chassis is designed for advanced synthetic biology and virtualization.")
                print(f"   Hardware requirements may be higher. Use with caution!")
            
            print(f"\nâœ… BioXen Hypervisor initialized successfully!")
            print(f"   Chassis: {self.chassis_type.value}")
            print(f"   Status: Ready for genome virtualization")
            
        except Exception as e:
            logger.error(f"Hypervisor initialization failed: {e}")
            print(f"âŒ Failed to initialize hypervisor: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def browse_available_genomes(self):
        """Browse and display available genomes with detailed information."""
        print("\nğŸ” Browse Available Genomes")
        print("ğŸ“‹ Scanning local genome collection...")
        
        # Check for real genomes in genomes directory
        genome_dir = Path("genomes")
        if not genome_dir.exists():
            print("âŒ No genomes directory found.")
            print("ğŸ’¡ Use 'Download genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        # Find all .genome files
        genome_files = list(genome_dir.glob("*.genome"))
        
        if not genome_files:
            print("âŒ No genome files found in genomes/ directory.")
            print("ğŸ’¡ Use 'Download genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        print(f"âœ… Found {len(genome_files)} real bacterial genomes")
        print("="*60)
        
        # Display each genome with details
        for i, genome_file in enumerate(genome_files, 1):
            try:
                # Try to get basic info about the genome
                name = genome_file.stem
                size_kb = genome_file.stat().st_size / 1024
                
                print(f"\n{i}. ğŸ§¬ {name}")
                print(f"   ğŸ“ File: {genome_file.name}")
                print(f"   ğŸ’¾ Size: {size_kb:.1f} KB")
                
                # Try to load more detailed info if possible
                integrator = BioXenRealGenomeIntegrator(genome_file)
                try:
                    stats = integrator.get_genome_stats()
                    if stats:
                        print(f"   ğŸ”¬ Genes: {stats.get('total_genes', 'Unknown')}")
                        if 'essential_genes' in stats:
                            essential_pct = stats.get('essential_percentage', 0)
                            print(f"   âš¡ Essential: {stats['essential_genes']} ({essential_pct:.1f}%)")
                        print(f"   ğŸ¦  Organism: {stats.get('organism', 'Unknown')}")
                        
                        # Show VM requirements
                        template = integrator.create_vm_template()
                        if template:
                            print(f"   ğŸ–¥ï¸  VM Memory: {template.get('min_memory_kb', 'Unknown')} KB")
                            print(f"   â±ï¸  Boot Time: {template.get('boot_time_ms', 'Unknown')} ms")
                except Exception:
                    print(f"   ğŸ“Š Status: File available (details pending validation)")
                    
            except Exception as e:
                logger.warning(f"Error reading genome {genome_file}: {e}")
                print(f"   âŒ Error reading genome: {e}")
                
        print("\n" + "="*60)
        print(f"ğŸ“‹ Total: {len(genome_files)} real bacterial genomes available")
        print("ğŸ’¡ Use 'Load Genome for Analysis' to work with a specific genome")
        print("ğŸ§¬ Use 'Create Virtual Machine' to virtualize these genomes")
        
        questionary.press_any_key_to_continue().ask()

    def download_genomes(self):
        """Download genomes from NCBI with interactive selection."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ“¥ Download Genomes from NCBI")
        print("âœ… BioXen supports real bacterial genome downloads and management")
        print("ğŸ“‹ Current collection: 5 real minimal bacterial genomes available")
        print("ğŸ”„ Options: Download all real genomes, individual genomes, or create simulated data for testing.")
        
        # Predefined interesting genomes with emojis and descriptions
        genome_options = [
            {
                "display": "ğŸŒ Download All Real Bacterial Genomes - Complete minimal genome collection",
                "accession": "download_all_real",
                "name": "all_real_genomes", 
                "size": 0
            },
            {
                "display": "ğŸ¦  E. coli K-12 MG1655 - Classic lab strain",
                "accession": "NC_000913.3",
                "name": "E_coli_K12_MG1655",
                "size": 4641652
            },
            {
                "display": "ğŸ„ S. cerevisiae S288C - Baker's yeast reference",
                "accession": "NC_001133.9", 
                "name": "S_cerevisiae_S288C",
                "size": 230218
            },
            {
                "display": "ğŸ”¬ Mycoplasma genitalium - Minimal genome",
                "accession": "NC_000908.2",
                "name": "M_genitalium",
                "size": 580076
            },
            {
                "display": "ğŸŒŠ Prochlorococcus marinus - Tiny ocean bacteria",
                "accession": "NC_009840.1",
                "name": "P_marinus",
                "size": 1751080
            },
            {
                "display": "ğŸ’€ Clostridium botulinum - Botox producer",
                "accession": "NC_009495.1", 
                "name": "C_botulinum",
                "size": 3886916
            },
            {
                "display": "ğŸ§ª Custom genome - Enter your own accession",
                "accession": "custom",
                "name": "custom",
                "size": 1000000
            }
        ]
        
        choice = questionary.select(
            "Select a genome to download:",
            choices=[Choice(opt["display"], opt) for opt in genome_options]
        ).ask()
        
        if choice is None:
            return
            
        if choice["accession"] == "download_all_real":
            self._download_all_real_genomes()
        elif choice["accession"] == "custom":
            self._download_custom_genome()
        else:
            self._download_individual_genome(choice)
        
        questionary.press_any_key_to_continue().ask()

    def _download_all_real_genomes(self):
        """Download all real bacterial genomes"""
        print("\nğŸŒ Downloading All Real Bacterial Genomes")
        print("ğŸ”„ Launching genome downloader for complete minimal genome collection...")
        print("ğŸ“‹ This will download: JCVI-Syn3A, M. genitalium, M. pneumoniae, C. ruddii, B. aphidicola")
        
        confirm = questionary.confirm(
            "Download all 5 real bacterial genomes? This may take several minutes."
        ).ask()
        
        if not confirm:
            return
            
        try:
            print("\nğŸ”„ Starting real genome download process...")
            
            # Run the download_genomes.py script with 'all' command
            result = subprocess.run([
                sys.executable, 'download_genomes.py', 'all'
            ], capture_output=True, text=True, cwd=Path(__file__).parent)
            
            if result.returncode == 0:
                print("âœ… Successfully downloaded all real bacterial genomes!")
                print("ğŸ“‹ Available genomes:")
                print("   â€¢ JCVI-Syn3A (538 KB, 187 genes)")
                print("   â€¢ Mycoplasma genitalium (580 KB, 1,108 genes)")
                print("   â€¢ Mycoplasma pneumoniae (823 KB, 1,503 genes)")
                print("   â€¢ Carsonella ruddii (174 KB, 473 genes)")
                print("   â€¢ Buchnera aphidicola (640 KB, 583 genes)")
                print("\nğŸ§¬ You can now use 'Browse Available Genomes' to work with these real genomes!")
            else:
                print(f"âŒ Download failed: {result.stderr}")
                print("ğŸ’¡ Try running 'python3 download_genomes.py' separately for more details")
                
        except Exception as e:
            logger.error(f"Genome download error: {e}")
            print(f"âŒ Error launching genome downloader: {e}")
            print("ğŸ’¡ Try running 'python3 download_genomes.py all' manually")

    def _download_individual_genome(self, genome_choice):
        """Download an individual genome"""
        accession = genome_choice["accession"]
        name = genome_choice["name"]
        size = genome_choice["size"]
        
        print(f"\nğŸŒ Downloading Real Genome: {name}")
        print(f"   Accession: {accession}")
        print(f"   Expected size: {size:,} base pairs")
        print(f"ğŸ’¡ Using NCBI download tools for authentic genome data")
        
        confirm = questionary.confirm(
            f"Download {name} from NCBI? This may take a few minutes."
        ).ask()
        
        if not confirm:
            return
        
        try:
            print(f"\nğŸ”„ Downloading {name} from NCBI...")
            
            # Use the genome download helper if available
            try:
                from genome_download_helper import GenomeDownloadHelper
                
                download_helper = GenomeDownloadHelper("genomes")
                success, message = download_helper.download_genome(accession, name)
                
                # Verify if file was actually downloaded
                genome_file = Path("genomes") / f"{name}.genome"
                file_actually_downloaded = genome_file.exists() and genome_file.stat().st_size > 1000
                
                if file_actually_downloaded:
                    file_size_mb = genome_file.stat().st_size / (1024 * 1024)
                    print(f"âœ… Successfully downloaded {name}!")
                    print(f"   ğŸ“Š Authentic NCBI data ({file_size_mb:.1f} MB)")
                    print(f"   ğŸ§¬ Ready for biological virtualization")
                    print(f"   ğŸ“ File: {genome_file}")
                elif success:
                    print(f"âœ… Download helper reported success: {message}")
                    print(f"   ğŸ“Š Authentic NCBI data for {name}")
                    print(f"   ğŸ§¬ Ready for biological virtualization")
                else:
                    print(f"âš ï¸  Download helper returned: {message}")
                    print("ğŸ”„ Creating simulated genome for testing...")
                    self._create_simulated_genome(accession, name, size)
                    
            except ImportError:
                print("âš ï¸  Advanced download helper not available")
                print("ğŸ”„ Creating simulated genome for testing...")
                self._create_simulated_genome(accession, name, size)
                
        except Exception as e:
            logger.error(f"Individual genome download error: {e}")
            print(f"âŒ Error downloading genome: {e}")
            print("ğŸ”„ Creating simulated genome for testing...")
            self._create_simulated_genome(accession, name, size)

    def _download_custom_genome(self):
        """Download a custom genome by accession"""
        accession = questionary.text("Enter NCBI accession number (e.g., NC_000913.3):").ask()
        if not accession:
            return
        name = questionary.text("Enter a name for this genome:").ask()
        if not name:
            name = accession.replace(".", "_")
        size = 1000000  # Default size for custom genomes
        
        genome_choice = {"accession": accession, "name": name, "size": size}
        self._download_individual_genome(genome_choice)

    def _create_simulated_genome(self, accession: str, name: str, size: int):
        """Create simulated genome data for testing purposes."""
        print(f"\nğŸ”„ Generating simulated genome data for {accession}...")
        print(f"ğŸ’¡ Creating simulated genome data for testing and development")
        
        try:
            # Create simulated genome data (random DNA sequence)
            import random
            bases = ['A', 'T', 'G', 'C']
            genome_data = ''.join(random.choice(bases) for _ in range(size))
            
            if genome_data:
                # Add to available genomes
                self.available_genomes.append({
                    "accession": accession,
                    "name": name,
                    "data": genome_data
                })
                print(f"âœ… Successfully created simulated {name}")
                print(f"   Accession: {accession}")
                print(f"   Size: {len(genome_data):,} base pairs")
                print(f"   âš ï¸  Note: This is simulated data for testing purposes")
            else:
                print(f"âŒ Failed to create genome data for {accession}")
        except Exception as e:
            logger.error(f"Simulated genome creation error: {e}")
            print(f"âŒ Error creating genome data: {e}")

    def validate_genomes(self):
        """Validate downloaded genomes."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ§¬ Load Genome for Analysis")
        print("ğŸ“‹ Scanning for available genomes...")
        
        # Check for real genomes in genomes directory
        genome_dir = Path("genomes")
        if not genome_dir.exists():
            print("âŒ No genomes directory found.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        # Find all .genome files
        genome_files = list(genome_dir.glob("*.genome"))
        
        if not genome_files:
            print("âŒ No genome files found in genomes/ directory.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        print(f"âœ… Found {len(genome_files)} genome files")
        
        # Create genome choices from actual files
        genome_choices = []
        valid_genomes = []
        
        for genome_file in genome_files:
            try:
                name = genome_file.stem
                size_kb = genome_file.stat().st_size / 1024
                
                # Try to get basic stats
                integrator = BioXenRealGenomeIntegrator(genome_file)
                try:
                    stats = integrator.get_genome_stats()
                    organism = stats.get('organism', name)
                    gene_count = stats.get('total_genes', 'Unknown')
                    display_name = f"ğŸ§¬ {organism} ({gene_count} genes, {size_kb:.1f} KB)"
                except Exception:
                    display_name = f"ğŸ§¬ {name} ({size_kb:.1f} KB)"
                
                genome_info = {
                    'name': name,
                    'file_path': genome_file,
                    'display_name': display_name
                }
                
                genome_choices.append(Choice(display_name, genome_info))
                valid_genomes.append(genome_info)
                
            except Exception as e:
                logger.warning(f"Could not read {genome_file.name}: {e}")
                print(f"âš ï¸  Warning: Could not read {genome_file.name}: {e}")
        
        if not valid_genomes:
            print("âŒ No valid genomes found.")
            print("ğŸ’¡ Use 'Download New Genomes' to get real bacterial genomes from NCBI")
            questionary.press_any_key_to_continue().ask()
            return
            
        genome_choices.append(Choice("ğŸ” Validate all genomes", "all"))
        
        choice = questionary.select(
            "Select a genome to validate:",
            choices=genome_choices
        ).ask()
        
        if choice is None:
            return
            
        if choice == "all":
            self._validate_all_genomes(valid_genomes)
        else:
            self._validate_single_genome(choice)
        
        questionary.press_any_key_to_continue().ask()

    def _validate_all_genomes(self, valid_genomes):
        """Validate all available genomes"""
        print("\nğŸ”„ Validating all available genomes...")
        all_valid = True
        for genome_info in valid_genomes:
            print(f"\nğŸ”¬ Validating {genome_info['name']}...")
            try:
                is_valid, messages = self.validator.validate_genome(genome_info['file_path'])
                if is_valid:
                    print(f"âœ… {genome_info['name']} is a valid BioXen genome.")
                else:
                    print(f"âŒ {genome_info['name']} is NOT a valid BioXen genome:")
                    for msg in messages:
                        print(f"   - {msg}")
                    all_valid = False
            except Exception as e:
                logger.error(f"Error validating {genome_info['name']}: {e}")
                print(f"âŒ Error validating {genome_info['name']}: {e}")
                all_valid = False
        
        if all_valid:
            print("\nâœ… All available genomes validated successfully!")
        else:
            print("\nâš ï¸  Some genomes failed validation. Check the logs above.")

    def _validate_single_genome(self, genome_choice):
        """Validate a single genome"""
        print(f"\nğŸ”¬ Validating {genome_choice['name']}...")
        try:
            is_valid, messages = self.validator.validate_genome(genome_choice['file_path'])
            if is_valid:
                print(f"âœ… {genome_choice['name']} is a valid BioXen genome.")
                self.available_genomes.append({
                    "name": genome_choice['name'],
                    "file_path": genome_choice['file_path'],
                    "data": None  # Data will be loaded when VM is created
                })
                print(f"ğŸ’¡ {genome_choice['name']} is now available for VM creation.")
            else:
                print(f"âŒ {genome_choice['name']} is NOT a valid BioXen genome:")
                for msg in messages:
                    print(f"   - {msg}")
        except Exception as e:
            logger.error(f"Error validating {genome_choice['name']}: {e}")
            print(f"âŒ Error validating {genome_choice['name']}: {e}")

    def create_vm(self):
        """Create a new virtual machine."""
        if not self._check_hypervisor():
            return

        print("\nâš¡ Create Virtual Machine")
        print("ğŸ“‹ Scanning for available genomes to virtualize...")

        genome_dir = Path("genomes")
        if not genome_dir.exists() or not list(genome_dir.glob("*.genome")):
            print("âŒ No genome files found. Please download or validate genomes first.")
            print("ğŸ’¡ Use 'Download New Genomes' or 'Load Genome for Analysis' options.")
            questionary.press_any_key_to_continue().ask()
            return

        genome_choices = []
        for genome_file in genome_dir.glob("*.genome"):
            try:
                integrator = BioXenRealGenomeIntegrator(genome_file)
                stats = integrator.get_genome_stats()
                organism_name = stats.get('organism', genome_file.stem)
                genome_choices.append(Choice(f"ğŸ§¬ {organism_name} ({genome_file.stem})", genome_file))
            except Exception:
                genome_choices.append(Choice(f"ğŸ§¬ {genome_file.stem} (Error reading details)", genome_file))

        if not genome_choices:
            print("âŒ No valid genomes found to create a VM from.")
            questionary.press_any_key_to_continue().ask()
            return

        selected_genome_path = questionary.select(
            "Select a genome to virtualize:",
            choices=genome_choices
        ).ask()

        if selected_genome_path is None:
            print("âŒ VM creation cancelled.")
            return

        genome_name = selected_genome_path.stem
        vm_id = self._suggest_unique_vm_id(genome_name)

        print(f"\nâš™ï¸  Configuring VM for {genome_name}")

        # Resource allocation
        min_memory_kb = 1024  # Default minimal memory
        boot_time_ms = 100   # Default minimal boot time
        try:
            integrator = BioXenRealGenomeIntegrator(selected_genome_path)
            template = integrator.create_vm_template()
            if template:
                min_memory_kb = template.get('min_memory_kb', min_memory_kb)
                boot_time_ms = template.get('boot_time_ms', boot_time_ms)
        except Exception as e:
            logger.warning(f"Could not load VM template from genome: {e}")
            print(f"âš ï¸  Could not load VM template from genome: {e}. Using default resources.")

        print(f"   Suggested Minimum Memory: {min_memory_kb} KB")
        print(f"   Suggested Boot Time: {boot_time_ms} ms")

        # Allow user to adjust resources
        mem_input = questionary.text(
            f"Enter memory allocation in KB (default: {min_memory_kb}):",
            default=str(min_memory_kb),
            validate=lambda x: x.isdigit() and int(x) > 0 or "Must be a positive number"
        ).ask()
        memory_kb = int(mem_input) if mem_input else min_memory_kb

        boot_input = questionary.text(
            f"Enter simulated boot time in ms (default: {boot_time_ms}):",
            default=str(boot_time_ms),
            validate=lambda x: x.isdigit() and int(x) > 0 or "Must be a positive number"
        ).ask()
        boot_time = int(boot_input) if boot_input else boot_time_ms

        resource_allocation = ResourceAllocation(memory_kb=memory_kb, boot_time_ms=boot_time)

        try:
            print(f"\nğŸ”„ Creating VM '{vm_id}' for {genome_name}...")
            self.hypervisor.create_vm(vm_id, selected_genome_path, resource_allocation)
            print(f"âœ… VM '{vm_id}' created successfully!")
            print(f"   Genome: {genome_name}")
            print(f"   Memory: {memory_kb} KB")
            print(f"   Boot Time: {boot_time} ms")
            print(f"   State: {self.hypervisor.get_vm_state(vm_id).value}")
        except Exception as e:
            logger.error(f"VM creation failed: {e}")
            print(f"âŒ Failed to create VM: {e}")

        questionary.press_any_key_to_continue().ask()

    def show_status(self):
        """Display the status of the hypervisor and running VMs."""
        if not self._check_hypervisor():
            return
            
        print("\nğŸ“Š BioXen Hypervisor Status")
        print("="*60)
        print(f"Chassis Type: {self.hypervisor.chassis_type.value}")
        print(f"Total Ribosomes: {self.hypervisor.chassis.total_ribosomes}")
        print(f"Available Ribosomes: {self.hypervisor.chassis.available_ribosomes}")
        print(f"Max VMs Supported: {self.hypervisor.chassis.max_vms}")
        print(f"Current Active VMs: {len(self.hypervisor.vms)}")
        print("="*60)
        
        if not self.hypervisor.vms:
            print("No virtual machines are currently running.")
            print("ğŸ’¡ Use 'Create Virtual Machine' to get started.")
        else:
            print("\nğŸ–¥ï¸  Virtual Machine States:")
            for vm_id, vm_instance in self.hypervisor.vms.items():
                state = self.hypervisor.get_vm_state(vm_id)
                print(f"   â€¢ VM ID: {vm_id}")
                print(f"     Status: {state.value}")
                print(f"     Genome: {vm_instance.genome_name}")
                print(f"     Memory: {vm_instance.resources.memory_kb} KB")
                print(f"     Boot Time: {vm_instance.resources.boot_time_ms} ms")
                
                # Add actions for running VMs
                if state == VMState.RUNNING:
                    vm_actions = questionary.select(
                        f"Actions for VM '{vm_id}':",
                        choices=[
                            Choice("â¹ï¸ Stop VM", "stop"),
                            Choice("ğŸ”„ Restart VM", "restart"),
                            Choice("ğŸ—‘ï¸ Destroy VM", "destroy"),
                            Choice("â†©ï¸ Back", "back")
                        ]
                    ).ask()
                    
                    if vm_actions == "stop":
                        self.hypervisor.stop_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' stopped.")
                    elif vm_actions == "restart":
                        self.hypervisor.restart_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' restarted.")
                    elif vm_actions == "destroy":
                        self.hypervisor.destroy_vm(vm_id)
                        print(f"âœ… VM '{vm_id}' destroyed.")
                    elif vm_actions == "back":
                        pass  # Go back to main status loop
        
        questionary.press_any_key_to_continue().ask()

    def destroy_vm(self):
        """Destroy a selected virtual machine."""
        if not self._check_hypervisor():
            return
        
        if not self.hypervisor.vms:
            print("âŒ No virtual machines to destroy.")
            questionary.press_any_key_to_continue().ask()
            return
            
        vm_choices = [Choice(f"{vm_id} ({self.hypervisor.get_vm_state(vm_id).value})", vm_id)
                      for vm_id in self.hypervisor.vms.keys()]
                      
        vm_to_destroy = questionary.select(
            "Select VM to destroy:",
            choices=vm_choices
        ).ask()
        
        if vm_to_destroy is None:
            print("âŒ VM destruction cancelled.")
            return
            
        confirm = questionary.confirm(f"Are you sure you want to destroy VM '{vm_to_destroy}'? This action is irreversible.").ask()
        
        if confirm:
            try:
                self.hypervisor.destroy_vm(vm_to_destroy)rint(f"âœ… VM '{vm_to_destroy}' destroyed.")
            except Exception as e:
                logger.error(f"VM destruction failed: {e}")
                print(f"âŒ Failed to destroy VM: {e}")
        
        questionary.press_any_key_to_continue().ask()

    def toggle_terminal_visualization(self):
        """Toggle terminal-based DNA visualization."""
        if not self._check_hypervisor():
            return
            
        if self.visualization_active:
            print("\nğŸ“º Stopping terminal visualization...")
            self.visualization_active = False
            if self.visualization_monitor:
                self.visualization_monitor.stop()
                self.visualization_monitor = None
            print("âœ… Terminal visualization stopped.")
        else:
            print("\nğŸ“º Starting terminal visualization...")
            try:
                # Placeholder for visualization implementation
                print("âš ï¸ Terminal visualization is not fully implemented yet.")
                self.visualization_active = True
                # self.visualization_monitor = SomeVisualizationClass()
                print("âœ… Terminal visualization started (placeholder).")
            except Exception as e:
                logger.error(f"Error starting visualization: {e}")
                print(f"âŒ Error starting visualization: {e}")
        
        questionary.press_any_key_to_continue().ask()

if __name__ == "__main__":
    bioxen = InteractiveBioXen()
    bioxen.main_menu()